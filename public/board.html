<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PaperTrail â€” map your evidence, follow the story.</title>
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />

    <!-- Primary SEO -->
    <meta name="application-name" content="PaperTrail" />
    <meta
      name="description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta
      name="keywords"
      content="evidence board, investigation, graph, nodes, links, mind map, research, PaperTrail"
    />
    <meta name="robots" content="index,follow" />
    <link rel="canonical" href="/" />
    <meta name="theme-color" content="#ffffff" />

    <!-- Open Graph / Facebook -->
    <meta property="og:site_name" content="PaperTrail" />
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="PaperTrail â€” map your evidence, follow the story."
    />
    <meta
      property="og:description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta property="og:url" content="/" />
    <meta property="og:image" content="/assets/og-image.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="PaperTrail â€” map your evidence, follow the story."
    />
    <meta
      name="twitter:description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta name="twitter:image" content="/assets/og-image.png" />

    <style>
      :root {
        --color-bg: #ffffff;
        --color-muted: #9ca3af;
        --color-ink: #e5e7eb;
        --color-accent: #60a5fa;
        --color-border-card: #e2e8f0;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--color-bg);
        color: var(--color-ink);
        font: 14px/1.4 ui-sans-serif, system-ui;
      }
      .toolbar__title {
        display: flex;
        flex-direction: column;
        margin-right: 1rem;
      }
      .toolbar__brand {
        font-weight: 700;
        font-size: 16px;
        color: #111827;
        text-decoration: none;
      }
      .toolbar__tagline {
        font-size: 11px;
        color: #6b7280;
      }
      .toolbar__board-name {
        font-size: 12px;
        color: #374151;
        margin-top: 2px;
        font-style: italic;
      }
      .toolbar__board-name[contenteditable="true"] {
        cursor: text;
        border-bottom: 1px dashed #e5e7eb;
        padding-bottom: 1px;
        line-height: 1.2;
        max-width: 280px;
        white-space: normal;
        overflow-wrap: anywhere;
      }
      .toolbar__board-name[contenteditable="true"]:focus {
        outline: none;
        border-bottom: 1px dashed #60a5fa;
      }
      .toolbar__board-name[contenteditable="true"]:empty:before {
        content: attr(data-placeholder);
        color: #9ca3af;
      }
      .toolbar {
        display: flex;
        gap: 0.5rem;
        padding: 0.5rem;
        background: #f9fafb;
        color: #111;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        align-items: flex-end;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .toolbar input,
      .toolbar button,
      .toolbar select {
        border: 1px solid #d1d5db;
        background: #ffffff;
        color: #111;
        padding: 0.45rem 0.8rem;
        border-radius: 0.4rem;
        cursor: pointer;
        font-weight: 500;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        transition: background 0.2s, box-shadow 0.2s;
        outline: none;
      }
      .toolbar__btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.45rem;
      }
      .toolbar__btn--icon svg {
        width: 18px;
        height: 18px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2;
      }
      .toolbar__btn--icon svg.filled {
        fill: currentColor;
        stroke: none;
      }
      .toolbar button:hover,
      .toolbar select:hover {
        background: #f3f4f6;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .toolbar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .toolbar__spacer {
        flex: 1;
      }
      .toolbar__search {
        min-width: 250px;
        cursor: text;
      }
      .toolbar__search-wrap {
        position: relative;
        display: inline-flex;
        align-items: center;
        max-width: 100%;
      }
      .toolbar__search-wrap input.toolbar__search {
        flex: 1 1 auto;
        width: 100%;
        padding-right: 1.8em;
        /* reserve space */
        box-sizing: border-box;
      }
      /* Avatar dropdown (context menu) */
      .toolbar__menu {
        position: relative;
      }
      .toolbar__menu summary {
        list-style: none;
        outline: none;
        cursor: pointer;
      }
      .toolbar__menu summary::-webkit-details-marker {
        display: none;
      }
      .toolbar__menu[open] .toolbar__avatar {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15),
          0 0 0 1px var(--color-border-card) inset;
      }
      .toolbar__menu-panel {
        position: absolute;
        top: calc(100% + 6px);
        right: 0;
        background: #fff;
        border: 1px solid var(--color-border-card);
        border-radius: 10px;
        box-shadow: var(--shadow);
        min-width: 160px;
        padding: 6px;
        z-index: 20;
      }
      .toolbar__avatar {
        width: 30px;
        height: 30px;
        border-radius: 999px;
        overflow: hidden;
        background: #e5e7eb;
        /* slate-200 */
        display: grid;
        place-items: center;
        border: 1px solid var(--color-border-card);
        box-shadow: var(--shadow);
      }
      .toolbar__avatar > img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .menu__item {
        display: block;
        padding: 8px 10px;
        border-radius: 8px;
        color: #0f172a;
        text-decoration: none;
        font-size: 14px;
      }
      .menu__item:hover {
        background: #f1f5f9;
      }
      #clearSearch {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        right: 6px;
        background: transparent;
        border: none;
        font-size: 12px;
        line-height: 1;
        padding: 0 2px 0 0;
        cursor: pointer;
        color: #6b7280;
      }
      #clearSearch:hover {
        color: #111;
      }
      #clearSearch:disabled {
        display: none;
      }
      /* Responsive toolbar */
      @media (max-width: 640px) {
        .toolbar {
          flex-wrap: wrap;
          gap: 6px;
          padding: 0.5rem 0.5rem 0.35rem;
        }
        .toolbar__title {
          flex: 1 1 100%;
          margin-right: 0;
        }
        .toolbar__brand {
          font-size: 15px;
        }
        .toolbar__tagline {
          font-size: 10px;
        }
        .toolbar__board-name {
          max-width: 100%;
          font-size: 12px;
        }
        .toolbar__spacer {
          display: none;
        }
        .toolbar__btn {
          padding: 0.35rem;
        }
        .toolbar__btn--icon svg {
          width: 16px;
          height: 16px;
        }
        /* Search gets its own row when wrapping */
        .toolbar__search-wrap {
          flex: 1 1 100%;
          min-width: 0;
          order: 10;
          position: relative;
          display: flex;
          align-items: center;
        }
        .toolbar__search-wrap input.toolbar__search {
          width: 100%;
        }
        /* Right-side controls come after search */
        #autoLayout,
        #export,
        #importBtn,
        #save,
        #reset,
        #infoBtn,
        #userBtn {
          order: 12;
        }
      }
      /* Board Styles */
      .board {
        position: relative;
        height: calc(100% - 24px);
        /* refined by JS to subtract toolbar height */
        overflow: auto;
        background-image: radial-gradient(
          var(--color-muted) 1px,
          transparent 1px
        );
        background-size: 16px 16px;
        background-position: -1px -1px;
      }
      #boardSizer {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        /* will be expanded via JS */
        height: 100%;
        /* will be expanded via JS */
        pointer-events: none;
        visibility: hidden;
      }
      /* SVG underlay for edges */
      svg#edges {
        position: absolute;
        left: 0;
        top: 0;
        /* no fixed CSS width/height; we size via JS to content extent */
        pointer-events: auto;
        overflow: visible;
      }
      .node {
        position: absolute;
        min-width: 120px;
        max-width: none;
        padding: 0.5rem;
        border-radius: 0.5rem;
        background: #f9fafb;
        border: 1px solid #d1d5db;
        color: #111;
        cursor: grab;
        user-select: none;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        box-sizing: border-box;
      }
      .node:active {
        cursor: grabbing;
      }
      .node__title {
        font-weight: 600;
        margin-bottom: 0.25rem;
        font-size: 13px;
        color: #111827;
        white-space: normal;
        overflow-wrap: anywhere;
        word-break: break-word;
      }
      .node__content {
        font-size: 13px;
        color: #1f2937;
        word-wrap: break-word;
      }
      .node img {
        display: block;
        width: 100%;
        height: auto;
        max-width: 100%;
        border-radius: 0.3rem;
        margin-bottom: 0.35rem;
      }
      .node__ports {
        position: absolute;
        top: 12px;
        /* better vertical centering with 13px title */
        left: 10px;
        /* balances with 20px title padding */
        display: flex;
        gap: 4px;
        margin-top: 0;
        align-items: center;
      }
      .node__port {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #94a3b8;
        transition: background 0.2s, border-color 0.2s;
        flex-shrink: 0;
      }
      .node__title {
        padding-left: 18px;
      }
      .node--link .node__content .rich {
        margin-top: 5px;
      }
      body.connect-mode .node .node__port {
        background: #ef4444;
        /* red */
        border-color: #b91c1c;
      }
      .toolbar__btn--active {
        background: #ef4444;
        color: #fff;
        border-color: #b91c1c;
        box-shadow: 0 2px 6px rgba(239, 68, 68, 0.3);
      }
      .toolbar__btn--active:hover {
        background: #dc2626;
        box-shadow: 0 3px 8px rgba(220, 38, 38, 0.35);
      }
      .node.selected {
        outline: 2px solid var(--color-accent);
      }
      /* Resize handle */
      .node__resizer {
        position: absolute;
        right: 2px;
        bottom: 2px;
        width: 14px;
        height: 14px;
        background: transparent;
        cursor: se-resize;
        display: none;
      }
      .node__resizer::after {
        content: "";
        position: absolute;
        right: 2px;
        bottom: 2px;
        width: 8px;
        height: 8px;
        border-right: 2px solid #9ca3af;
        border-bottom: 2px solid #9ca3af;
        box-sizing: border-box;
      }
      .node:hover .node__resizer,
      .node:focus-within .node__resizer {
        display: block;
      }
      .edge {
        stroke: red;
        stroke-width: 2;
        fill: none;
        stroke-linecap: round;
        stroke-linejoin: round;
        pointer-events: stroke;
        /* enable clicks on the line only */
        cursor: pointer;
      }
      .edge__endpoint {
        fill: red;
        stroke: #b91c1c;
        stroke-width: 1.2;
        pointer-events: none;
      }
      .edge--selected {
        stroke: var(--color-accent);
        stroke-width: 3;
      }
      .edge:hover {
        stroke-width: 3;
      }
      .edge--dashed {
        stroke-dasharray: 6 6;
      }
      .edge--ghost {
        stroke: #9ca3af;
        /* muted */
        stroke-width: 2;
        fill: none;
        stroke-dasharray: 6 6;
        pointer-events: none;
        /* don't block clicks */
      }
      .edge__label {
        fill: #374151;
        font-size: 11px;
        font-weight: 500;
        user-select: none;
        paint-order: stroke;
        stroke: #f9fafb;
        stroke-width: 2px;
      }
      .statusbar__hint {
        color: #000000;
        margin-left: 0.5rem;
      }
      .context-menu {
        position: absolute;
        min-width: 180px;
        background: #ffffff;
        border: 1px solid #d1d5db;
        border-radius: 0.5rem;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
        padding: 0.25rem;
        z-index: 1000;
        display: none;
        color: #111;
      }
      .context-menu__item {
        width: 100%;
        display: block;
        text-align: left;
        background: transparent;
        border: 0;
        color: #111;
        padding: 0.5rem 0.6rem;
        border-radius: 0.4rem;
        cursor: pointer;
        transition: background 0.15s ease-in-out;
      }
      .context-menu__item:hover {
        background: #f3f4f6;
      }
      /* Inline rich text toolbar */
      .rtb {
        position: absolute;
        top: 6px;
        right: 6px;
        display: none;
        background: rgba(255, 255, 255, 0.98);
        border: 1px solid #d1d5db;
        border-radius: 0.4rem;
        padding: 2px;
        gap: 2px;
        z-index: 5;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
      }
      .node:hover .rtb,
      .node:focus-within .rtb {
        display: flex;
      }
      .rtb button {
        border: 0;
        background: transparent;
        color: #111;
        padding: 4px 6px;
        font-size: 12px;
        border-radius: 0.3rem;
        cursor: pointer;
        transition: background 0.15s ease-in-out;
      }
      .rtb button:hover {
        background: #f3f4f6;
      }
      .rich {
        outline: none;
        white-space: pre-wrap;
      }
      .rich a {
        color: #93c5fd;
        text-decoration: underline;
      }
      /* Discoverable editable areas */
      .node__title[contenteditable="false"] {
        cursor: pointer;
        /* single-click selects; dblclick enables editing */
      }
      .node__title[contenteditable="true"] {
        cursor: text;
        border-bottom: 1px dashed #e5e7eb;
        padding-bottom: 2px;
      }
      .node:hover .node__title[contenteditable="true"] {
        border-bottom-color: #d1d5db;
      }
      .node__title[contenteditable="true"]:focus {
        outline: none;
        border-bottom-color: #60a5fa;
        box-shadow: inset 0 -1px 0 #60a5fa;
      }
      .node__title[contenteditable="true"]:empty:before {
        content: attr(data-placeholder);
        color: #9ca3af;
      }
      .rich[contenteditable="true"] {
        cursor: text;
        min-height: 56px;
        padding: 6px 8px;
        background: #ffffff;
        border: 1px dashed #d1d5db;
        border-radius: 6px;
        transition: border-color 0.15s ease, box-shadow 0.15s ease;
      }
      .node:hover .rich[contenteditable="true"] {
        border-color: #cbd5e1;
      }
      .rich[contenteditable="true"]:focus {
        outline: none;
        border-color: #60a5fa;
        box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2);
        background: #fff;
      }
      .rich[contenteditable="true"]:empty:before {
        content: attr(data-placeholder);
        color: #9ca3af;
      }
      /* Small edit affordance on hover */
      .editable-hint::after {
        content: "âœŽ";
        font-size: 11px;
        color: #9ca3af;
        margin-left: 6px;
        opacity: 0;
        transition: opacity 0.15s ease;
      }
      .node:hover .editable-hint::after,
      .editable-hint:focus::after {
        opacity: 1;
      }
      /* Tags */
      .tags {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 2px 8px;
        border-radius: 999px;
        background: #e5e7eb;
        color: #111827;
        font-size: 11px;
        border: 1px solid #d1d5db;
      }
      .chip button {
        border: 0;
        background: transparent;
        color: #9ca3af;
        cursor: pointer;
        font-size: 11px;
        padding: 0;
      }
      .chip button:hover {
        color: #e5e7eb;
      }
      .add-tag {
        margin-top: 6px;
        background: #f3f4f6;
        border: 1px dashed #d1d5db;
        color: #374151;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 11px;
        cursor: pointer;
      }
      .node.dim {
        opacity: 0.35;
        filter: grayscale(0.3);
      }
      .highlight {
        outline: 2px dashed var(--color-accent);
      }
      .add-desc {
        margin-top: 6px;
        background: #ffffff;
        border: 1px dashed #d1d5db;
        color: #374151;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 11px;
        cursor: pointer;
      }
      /* Link preview card */
      .link-card {
        display: grid;
        grid-template-columns: 56px 1fr;
        gap: 10px;
        align-items: center;
        padding: 8px;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        background: #ffffff;
        text-decoration: none;
      }
      .link-card .thumb {
        width: 56px;
        height: 56px;
        border-radius: 6px;
        background: #f3f4f6;
        object-fit: cover;
        display: block;
      }
      .link-card .meta {
        min-width: 0;
      }
      .link-card .title {
        font-weight: 600;
        color: #111827;
        font-size: 13px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding: 0;
      }
      .link-card .desc {
        color: #374151;
        font-size: 12px;
        max-height: 2.6em;
        overflow: hidden;
        display: -webkit-box;
        /* legacy clamp layout */
        line-clamp: 2;
        /* standard property */
        -webkit-line-clamp: 2;
        /* vendor fallback */
        -webkit-box-orient: vertical;
      }
      .link-card .site {
        color: #6b7280;
        font-size: 11px;
        margin-top: 2px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .link-card .icon {
        width: 14px;
        height: 14px;
        vertical-align: -2px;
        margin-right: 6px;
        border-radius: 3px;
      }
      .link-card a {
        color: #2563eb;
        text-decoration: none;
      }
      /* Status bar */
      .statusbar {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 2px 12px;
        background: transparent;
        border: none;
        color: #000;
        z-index: 20;
        font-size: smaller;
      }
      .statusbar .statusbar__text {
        color: #000;
      }
      /* About modal */
      .modal__backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      }
      .modal__backdrop.show {
        display: flex;
      }
      .modal {
        background: #fff;
        color: #111827;
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        width: min(560px, 90vw);
        max-height: 80vh;
        overflow: auto;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
      }
      .modal__header {
        padding: 14px 16px;
        border-bottom: 1px solid #f3f4f6;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .modal__title {
        margin: 0;
        font-size: 16px;
      }
      .modal__close {
        border: 0;
        background: transparent;
        cursor: pointer;
        font-size: 18px;
        color: #6b7280;
      }
      .modal__close:hover {
        color: #111827;
      }
      .modal__body {
        padding: 0 25px 25px;
        font-size: smaller;
      }
      .kv {
        display: grid;
        grid-template-columns: 140px 1fr;
        gap: 5px;
        margin-top: 8px;
      }
      .kv div {
        padding: 2px 0;
      }
    </style>
  </head>

  <body>
    <div class="toolbar">
      <div class="toolbar__title">
        <a class="toolbar__brand" href="/">PaperTrail</a>
        <div class="toolbar__tagline">map your evidence, follow the story.</div>
        <div
          class="toolbar__board-name"
          id="boardName"
          contenteditable="true"
          data-placeholder="Untitled Board"
        ></div>
      </div>
      <button
        id="addText"
        class="toolbar__btn toolbar__btn--icon"
        title="Add text"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="3" width="16" height="18" rx="2" ry="2" />
          <line x1="8" y1="9" x2="16" y2="9" />
          <line x1="8" y1="13" x2="16" y2="13" />
          <line x1="8" y1="17" x2="14" y2="17" />
        </svg>
      </button>
      <button
        id="addImage"
        class="toolbar__btn toolbar__btn--icon"
        title="Add image (URL)"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="3" y="5" width="18" height="14" rx="2" />
          <path d="M7 15l3-3 3 3 4-4 3 3" />
          <circle cx="9" cy="9" r="1.5" />
        </svg>
      </button>
      <button
        id="uploadImage"
        class="toolbar__btn toolbar__btn--icon"
        title="Upload image"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 15V5" />
          <path d="M8 9l4-4 4 4" />
          <path d="M4 19h16" />
        </svg>
      </button>
      <input
        id="fileInput"
        type="file"
        accept="image/*"
        style="display: none"
      />
      <button
        id="addLink"
        class="toolbar__btn toolbar__btn--icon"
        title="Add link"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M10 14l-2 2a4 4 0 0 1-6-6l2-2" />
          <path d="M14 10l2-2a4 4 0 0 1 6 6l-2 2" />
          <path d="M8 12l8-8" opacity="0.0" />
        </svg>
      </button>
      <button
        id="connect"
        class="toolbar__btn toolbar__btn--icon"
        title="Connect nodes (C)"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="6" cy="12" r="2" />
          <circle cx="18" cy="6" r="2" />
          <circle cx="18" cy="18" r="2" />
          <path d="M8 12h6" />
          <path d="M12 12L17 7" />
          <path d="M12 12l5 5" />
        </svg>
      </button>
      <div class="toolbar__search-wrap">
        <input
          id="search"
          class="toolbar__search"
          type="search"
          placeholder="Searchâ€¦ (use #tag)"
        />
        <button id="clearSearch" title="Clear search">âœ•</button>
      </div>
      <div class="toolbar__spacer"></div>
      <button
        id="autoLayout"
        class="toolbar__btn toolbar__btn--icon"
        title="Auto layout"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="4" width="6" height="6" />
          <rect x="14" y="4" width="6" height="6" />
          <rect x="4" y="14" width="6" height="6" />
          <rect x="14" y="14" width="6" height="6" />
        </svg>
      </button>
      <button
        id="export"
        class="toolbar__btn toolbar__btn--icon"
        title="Export board"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 5v10" />
          <path d="M8 9l4-4 4 4" />
          <path d="M4 19h16" />
        </svg>
      </button>
      <button
        id="importBtn"
        class="toolbar__btn toolbar__btn--icon"
        title="Import board"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 19V9" />
          <path d="M8 15l4 4 4-4" />
          <path d="M4 5h16" />
        </svg>
      </button>
      <input
        id="importFile"
        type="file"
        accept="application/zip,application/x-zip-compressed,.zip,application/json"
        style="display: none"
      />
      <button
        id="save"
        class="toolbar__btn toolbar__btn--icon"
        disabled
        title="Save"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="4" width="16" height="16" rx="2" />
          <rect x="8" y="4" width="8" height="6" />
          <rect x="9" y="14" width="6" height="6" />
        </svg>
      </button>
      <button
        id="reset"
        class="toolbar__btn toolbar__btn--icon"
        title="Reset board"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 12a9 9 0 1 0 3-6" />
          <path d="M3 4v6h6" />
        </svg>
      </button>
      <button
        id="infoBtn"
        class="toolbar__btn toolbar__btn--icon"
        title="About / Info"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="12" r="10" />
          <circle cx="12" cy="8" r="1.4" />
          <path d="M12 11v5" stroke-linecap="round" />
        </svg>
      </button>
      <details id="userBtn" class="toolbar__menu">
        <summary class="toolbar__avatar" title="{{handler}}">
          <!-- If you have a real avatar URL, replace the SVG with <img src="{{avatarUrl}}" alt="{{handler}}'s avatar"> -->
          <svg
            width="18"
            height="18"
            viewBox="0 0 24 24"
            fill="none"
            aria-hidden="true"
          >
            <circle cx="12" cy="8" r="4" fill="#111" />
            <path d="M4 20c0-4 4-6 8-6s8 2 8 6" fill="#111" />
          </svg>
        </summary>
        <div class="toolbar__menu-panel" role="menu" aria-label="User menu">
          <a class="menu__item" href="/logout" role="menuitem">Logout</a>
        </div>
      </details>
    </div>
    <div class="board" id="board">
      <div id="boardSizer"></div>
      <svg id="edges"></svg>
    </div>
    <div id="ctxMenu" class="context-menu"></div>
    <div class="statusbar">
      <span id="status" class="statusbar__text"></span>
      <span class="statusbar__hint" id="modeHint"
        >ðŸ’¡ Mode: Select/Move. Press C to toggle connect mode.</span
      >
    </div>
    <div
      id="aboutModal"
      class="modal__backdrop"
      role="dialog"
      aria-modal="true"
      aria-labelledby="aboutTitle"
    >
      <div class="modal">
        <header class="modal__header">
          <h3 id="aboutTitle" class="modal__title">
            PaperTrail â€” map your evidence, follow the story
          </h3>
          <button
            type="button"
            id="aboutClose"
            class="modal__close"
            aria-label="Close"
          >
            âœ•
          </button>
        </header>
        <div class="modal__body">
          <p>
            <em>PaperTrail</em> is a lightweight visual evidence board for
            organizing ideas, documents, images, and links. It lets you pin down
            pieces of information, connect them freely, and uncover patterns.
            Whether youâ€™re researching, investigating, or just making sense of
            complex projects, PaperTrail helps you create a clear trail of
            evidence you can return to and share.
          </p>
          <p>
            At this stage, PaperTrail is designed as a single-user,
            single-workspace app. That means there is only one active board
            available at a time. Features such as real-time collaboration,
            multi-user access, or simultaneous editing are not yet supported.
          </p>
          <p>
            If you want to manage multiple boards or workspaces, you can still
            do so manually using the Import/Export features:
          </p>
          <ul>
            <li>Export your current board as a .zip file to save it.</li>
            <li>
              Import a previously exported board to continue working on it.
            </li>
            <li>
              You are responsible for organizing these exported files if you
              wish to maintain multiple workspaces.
            </li>
          </ul>
          <p>
            This setup is lightweight and simple, making it ideal for solo use,
            prototyping, or testing out ideas. Future versions of PaperTrail may
            add multi-board support and collaboration features.
          </p>
          <div class="kv">
            <div>App version</div>
            <div id="aboutAppVersion">â€”</div>
            <div>Schema version</div>
            <div id="aboutSchemaVersion">â€”</div>
            <div>Current board</div>
            <div id="aboutBoardName">â€”</div>
          </div>
        </div>
      </div>
    </div>
    <script>
      // Binding for dynamic values from server
      // (injected by server-side templating)
      window.__globals = {
        appVersion: "{{appVersion}}",
        schemaVersion: "{{schemaVersion}}",
        board: { id: "{{boardId}}" },
      };

      // --- App State ---
      const $ = (sel) => document.querySelector(sel);
      const toolbarEl = $(".toolbar");
      const boardEl = $("#board");
      const edgesSvg = $("#edges");
      const statusEl = $("#status");
      let saveBtn = document.getElementById("save");
      const exportBtn = document.getElementById("export");
      const importBtn = document.getElementById("importBtn");
      const importFile = document.getElementById("importFile");
      const searchInput = document.getElementById("search");
      const infoBtn = document.getElementById("infoBtn");
      const aboutModal = document.getElementById("aboutModal");
      const aboutClose = document.getElementById("aboutClose");
      let lastSavedJSON = null;

      // --- Ensure DOM positions/sizes are synced to the model prior to save
      function syncDomToModel() {
        for (const n of board.nodes) {
          const el = document.getElementById(n.id);
          if (!el) continue;
          const left = Number.parseFloat(el.style.left);
          const top = Number.parseFloat(el.style.top);
          n.x = Number.isFinite(left) ? left : el.offsetLeft || n.x || 0;
          n.y = Number.isFinite(top) ? top : el.offsetTop || n.y || 0;
          // Persist measured size so edges/auto-layout remain consistent after reload
          n.w = Math.trunc(el.offsetWidth || n.w || 0) || undefined;
          n.h = Math.trunc(el.offsetHeight || n.h || 0) || undefined;
        }
      }

      // Rebind the Save button to guarantee our latest handler and avoid duplicate listeners
      function wireSaveButton() {
        const oldBtn = document.getElementById("save");
        const newBtn = oldBtn.cloneNode(true); // drops prior listeners
        oldBtn.parentNode.replaceChild(newBtn, oldBtn);
        saveBtn = newBtn;

        newBtn.addEventListener("click", async () => {
          try {
            newBtn.disabled = true;
            // Always sync the latest DOM position/size state before snapshot + POST
            syncDomToModel();
            const payload = { ...board, id: window.__globals.board.id };
            const resp = await fetch(
              `/api/board/${encodeURIComponent(window.__globals.board.id)}`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              }
            );
            const data = await resp.json().catch(() => ({}));
            if (!resp.ok)
              throw new Error(data && data.error ? data.error : "Save failed");
            // Update local model with canonical server state
            board = data;
            lastSavedJSON = computeSnapshot();
            showStatus("Saved.", { ttl: 1600 });
            render();
            updateSaveButton();
          } catch (e) {
            showStatus(e && e.message ? e.message : "Save failed", {
              sticky: true,
            });
          } finally {
            updateSaveButton();
          }
        });
      }

      // Ghost edge state
      let ghostPath = null; // SVGPathElement
      let lastMouse = { x: 0, y: 0 };

      function ensureGhostPath() {
        if (!ghostPath) {
          ghostPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          ghostPath.setAttribute("class", "edge edge--ghost");
          edgesSvg.appendChild(ghostPath);
        } else if (!edgesSvg.contains(ghostPath)) {
          edgesSvg.appendChild(ghostPath);
        }
      }
      function hideGhost() {
        if (ghostPath) ghostPath.setAttribute("d", "");
      }
      function boardPointFromClient(ev) {
        const rect = boardEl.getBoundingClientRect();
        return {
          x: boardEl.scrollLeft + (ev.clientX - rect.left),
          y: boardEl.scrollTop + (ev.clientY - rect.top),
        };
      }
      function renderGhostEdge() {
        if (!connectMode || !connectFromId) {
          hideGhost();
          return;
        }
        const src = board.nodes.find((n) => n.id === connectFromId);
        if (!src) {
          hideGhost();
          return;
        }
        // Use the same smooth cubic logic as permanent edges
        const mx = lastMouse.x,
          my = lastMouse.y;
        const a1 = anchorPoint(src, mx, my);
        const a2 = mouseAnchor(src, mx, my);
        ensureGhostPath();
        ghostPath.setAttribute("d", smoothCubic(a1, a2));
      }

      function adjustBoardHeight() {
        const tb = toolbarEl ? toolbarEl.offsetHeight : 0;
        // 24px = status bar height
        boardEl.style.height = `calc(100% - ${tb}px - 24px)`;
        updateBoardExtent();
      }
      window.addEventListener("resize", adjustBoardHeight);

      boardEl.addEventListener("mousemove", (ev) => {
        lastMouse = boardPointFromClient(ev);
        if (connectMode && connectFromId) renderGhostEdge();
      });
      // Also update when moving over the SVG layer (useful when pointer leaves node area)
      edgesSvg.addEventListener("mousemove", (ev) => {
        lastMouse = boardPointFromClient(ev);
        if (connectMode && connectFromId) renderGhostEdge();
      });

      // Unified status & mode controller
      const ui = {
        connectMode: false,
        status: { text: "", timer: null, sticky: false },
      };
      function renderStatusBar() {
        const modeText = ui.connectMode
          ? "ðŸ’¡ Mode: Connect"
          : "ðŸ’¡ Mode: Select/Move (press C to connect)";
        document.getElementById("modeHint").textContent = modeText;
        statusEl.textContent = ui.status.text || "";
      }
      function setConnectMode(on) {
        ui.connectMode = !!on;
        document.body.classList.toggle("connect-mode", ui.connectMode);
        const connectBtn = document.getElementById("connect");
        connectBtn.classList.toggle("toolbar__btn--active", ui.connectMode);

        // Disable/enable other toolbar controls
        document.querySelectorAll(".toolbar button").forEach((btn) => {
          if (btn.id === "connect") return;
          btn.disabled = ui.connectMode;
        });

        renderStatusBar();
      }

      // Show a transient status message; use {sticky:true} to persist until changed
      function showStatus(msg, opts = {}) {
        const { sticky = false, ttl = 2200 } = opts;
        // Avoid flicker: ignore if message unchanged
        if (ui.status.text === msg && ui.status.sticky === sticky) return;
        ui.status.text = msg;
        ui.status.sticky = sticky;
        statusEl.textContent = ui.status.text;
        if (ui.status.timer) {
          clearTimeout(ui.status.timer);
          ui.status.timer = null;
        }
        if (!sticky) {
          ui.status.timer = setTimeout(() => {
            ui.status.text = "";
            ui.status.sticky = false;
            renderStatusBar();
          }, ttl);
        }
      }

      // Back-compat wrappers so existing calls keep working
      function setStatus(msg) {
        showStatus(msg);
      }

      const boardNameEl = document.getElementById("boardName");

      // Keep single-line feel: prevent Enter/Return from inserting new lines
      boardNameEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          boardNameEl.blur();
        }
      });

      // Update model on input and enable Save
      boardNameEl.addEventListener("input", () => {
        board.title = (boardNameEl.textContent || "").trim();
        markDirty();
      });

      // On blur, ensure a non-empty title for display (model can be empty if desired)
      boardNameEl.addEventListener("blur", () => {
        if (!boardNameEl.textContent || !boardNameEl.textContent.trim()) {
          boardNameEl.textContent = "Untitled Board";
        }
      });

      function isTypingTarget(el) {
        if (!el) return false;
        if (el.isContentEditable) return true;
        const tag = (el.tagName || "").toUpperCase();
        return tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
      }

      function stableBoardSnapshot(b) {
        // Create a deterministic snapshot that ignores volatile fields (like updatedAt)
        // and normalizes numeric values so tiny float jitter doesn't flip the Save button.
        return {
          id: b.id,
          title: b.title || "",
          visibility: b.visibility || "public",
          // Normalize nodes and only include fields that affect persistence
          nodes: (b.nodes || []).map((n) => ({
            id: n.id,
            type: n.type,
            x: Math.round(n.x || 0),
            y: Math.round(n.y || 0),
            w: Number.isFinite(n.w) ? Math.round(n.w) : undefined,
            h: Number.isFinite(n.h) ? Math.round(n.h) : undefined,
            data: n.data || {},
          })),
          // Normalize edges similarly
          edges: (b.edges || []).map((e) => ({
            id: e.id,
            sourceId: e.sourceId,
            targetId: e.targetId,
            label: e.label || undefined,
            dashed: !!e.dashed,
            color: e.color || undefined,
          })),
          createdAt: b.createdAt || undefined,
          // NOTE: updatedAt is intentionally excluded from snapshot comparison
        };
      }
      function computeSnapshot() {
        return JSON.stringify(stableBoardSnapshot(board));
      }
      function updateSaveButton() {
        const snap = computeSnapshot();
        // On first run, capture a clean baseline so Save starts disabled,
        // and subsequent changes correctly enable the button.
        if (lastSavedJSON === null) {
          lastSavedJSON = snap;
          saveBtn.disabled = true;
          return;
        }
        saveBtn.disabled = snap === lastSavedJSON;
      }
      function markDirty() {
        // Record mutation time (not part of snapshot equivalence)
        try {
          board.updatedAt = new Date().toISOString();
        } catch (_) {}
        // Re-evaluate against the last saved snapshot so moving a node back disables Save
        updateSaveButton();
      }
      const ctxMenu = document.getElementById("ctxMenu");
      let ctxTarget = null; // { type: 'node'|'edge', id: string }

      function showContextMenu(x, y, target) {
        ctxTarget = target; // { type, id }
        const menu = ctxMenu;

        // Build menu dynamically based on target type
        if (ctxTarget && ctxTarget.type === "edge") {
          menu.innerHTML = `
            <button class="context-menu__item" data-action="label">Edit label</button>
            <button class="context-menu__item" data-action="dashed">Toggle dashed</button>
            <button class="context-menu__item" data-action="color">Set colorâ€¦</button>
            <button class="context-menu__item" data-action="delete">Delete</button>
          `;
        } else {
          const node = board.nodes.find((n) => n.id === target.id);
          if (node && node.type === "link") {
            menu.innerHTML = `
              <button class="context-menu__item" data-action="edit-link-url">Edit link URLâ€¦</button>
              <button class="context-menu__item" data-action="delete">Delete</button>
            `;
          } else {
            menu.innerHTML = `
              <button class="context-menu__item" data-action="delete">Delete</button>
            `;
          }
        }

        menu.style.display = "block";
        // constrain within window
        const mw = menu.offsetWidth || 160;
        const mh = menu.offsetHeight || 44;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        let px = x,
          py = y;
        if (px + mw > vw) px = vw - mw - 8;
        if (py + mh > vh) py = vh - mh - 8;
        menu.style.left = px + "px";
        menu.style.top = py + "px";
      }
      function hideContextMenu() {
        ctxMenu.style.display = "none";
        ctxTarget = null;
      }

      // clicking elsewhere hides menu
      document.addEventListener("mousedown", (ev) => {
        if (ctxMenu.style.display === "block") {
          const within = ctxMenu.contains(ev.target);
          if (!within) hideContextMenu();
        }
      });

      // Esc hides menu
      document.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape") hideContextMenu();
      });

      // Context menu actions (delegated)
      ctxMenu.addEventListener("click", (ev) => {
        const btn = ev.target.closest("button");
        if (!btn) return;
        const action = btn.getAttribute("data-action");
        if (!ctxTarget) {
          hideContextMenu();
          return;
        }

        if (ctxTarget.type === "node") {
          const node = board.nodes.find((n) => n.id === ctxTarget.id);
          if (!node) {
            hideContextMenu();
            return;
          }

          if (action === "delete") {
            selectedNodeId = ctxTarget.id;
            selectedEdgeId = null;
            hideContextMenu();
            removeSelection();
            return;
          }

          if (action === "edit-link-url" && node.type === "link") {
            const val = prompt("Link URL:", node.data.linkUrl || "https://");
            if (val !== null) {
              const url = (val || "").trim();
              if (url) {
                node.data.linkUrl = url;
                // Invalidate previous preview so it refetches
                delete node.data.preview;
                hideContextMenu();
                markDirty();
                renderNode(node);
                renderEdges();
              }
            }
            return;
          }
          hideContextMenu();
          return;
        }

        // Edge actions
        const edge = board.edges.find((e) => e.id === ctxTarget.id);
        if (!edge) {
          hideContextMenu();
          return;
        }

        if (action === "delete") {
          selectedEdgeId = edge.id;
          selectedNodeId = null;
          hideContextMenu();
          removeSelection();
        } else if (action === "label") {
          const val = prompt("Edge label:", edge.label || "");
          if (val !== null) {
            edge.label = val.trim();
            hideContextMenu();
            markDirty();
            renderEdges();
          }
        } else if (action === "dashed") {
          edge.dashed = !edge.dashed;
          hideContextMenu();
          markDirty();
          renderEdges();
        } else if (action === "color") {
          const val = prompt(
            "Stroke color (e.g. #f87171 or red). Leave blank to reset:",
            edge.color || ""
          );
          if (val === null) return;
          const v = val.trim();
          if (v === "") delete edge.color;
          else edge.color = v;
          hideContextMenu();
          markDirty();
          renderEdges();
        }
      });

      let board = {
        id: "board-1",
        title: "My Evidence Board",
        nodes: [],
        edges: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Initialize board name display from default board.title
      boardNameEl.textContent = board.title || "";
      // Establish initial clean snapshot so Save enables on changes
      updateSaveButton();
      wireSaveButton();

      (async function loadInitialBoard() {
        try {
          const resp = await fetch(
            `/api/board/${encodeURIComponent(window.__globals.board.id)}`
          );
          if (!resp.ok) throw new Error("not found");
          const board = await resp.json();
          boardNameEl.textContent = board.title;
          lastSavedJSON = computeSnapshot();
          render();
          updateSaveButton();
          wireSaveButton();
        } catch (e) {
          console.error("Failed to load board:", window.__globals.board.id, e);
          window.location.href = "/404.html";
        }
      })();

      let selectedNodeId = null;
      let selectedEdgeId = null;
      let connectMode = false;
      let connectFromId = null;

      const genId = (p = "id") =>
        p + "-" + Math.random().toString(36).slice(2, 8);

      function addNode(type, at = { x: 100, y: 100 }, payload = {}) {
        const id = genId("n");
        const base = {
          id,
          type,
          x: at.x,
          y: at.y,
          w: 240,
          h: undefined,
          data: {},
        };
        if (type === "text") {
          base.data.text = payload.text ?? "New note...";
          base.data.html = escapeHtml(base.data.text);
          base.data.title = payload.title ?? "Text";
        } else if (type === "image") {
          // Ask for URL if not provided; cancel = no node
          let url = payload.imageUrl;
          if (url === undefined) {
            url = prompt("Image URL?", "");
          }
          if (url === null) return null; // user cancelled
          url = (url || "").trim();
          if (!url) return null; // empty -> abort
          base.data.imageUrl = url;
          base.data.title = payload.title ?? "Image";
          base.data.descHtml = payload.descHtml ?? ""; // optional description (rich)
        } else if (type === "link") {
          // Ask for URL if not provided; cancel = no node
          let url = payload.linkUrl;
          if (url === undefined) {
            url = prompt("Link URL?", "https://");
          }
          if (url === null) return null; // user cancelled
          url = (url || "").trim();
          if (!url) return null; // empty -> abort
          base.data.linkUrl = url;
          base.data.title = payload.title ?? "Link";
          base.data.descHtml = payload.descHtml ?? ""; // optional description (rich)
        }
        board.nodes.push(base);
        markDirty();
        render();
        return base;
      }

      function addEdge(sourceId, targetId) {
        if (!sourceId || !targetId || sourceId === targetId) return;
        const already = board.edges.find(
          (e) => e.sourceId === sourceId && e.targetId === targetId
        );
        if (already) return;
        board.edges.push({ id: genId("e"), sourceId, targetId });
        markDirty();
        renderEdges();
      }

      function removeSelection() {
        if (selectedNodeId) {
          board.edges = board.edges.filter(
            (e) =>
              e.sourceId !== selectedNodeId && e.targetId !== selectedNodeId
          );
          board.nodes = board.nodes.filter((n) => n.id !== selectedNodeId);
          setStatus("Node deleted.");
          selectedNodeId = null;
        } else if (selectedEdgeId) {
          board.edges = board.edges.filter((e) => e.id !== selectedEdgeId);
          setStatus("Edge deleted.");
          selectedEdgeId = null;
        }
        markDirty();
        render();
      }

      function nodeBounds(n) {
        const el = document.getElementById(n.id);
        if (el) {
          // Use live DOM position to prevent model/view drift after save
          const left =
            Number.parseFloat(el.style.left) || el.offsetLeft || n.x || 0;
          const top =
            Number.parseFloat(el.style.top) || el.offsetTop || n.y || 0;
          const w = n.w || el.offsetWidth || 200;
          const h = n.h || el.offsetHeight || 80;
          return { x: left, y: top, w, h };
        }
        // Fallback to model values if DOM element isn't mounted yet
        return {
          x: n.x,
          y: n.y,
          w: n.w || 200,
          h: n.h || 80,
        };
      }

      function centerOf(n) {
        const b = nodeBounds(n);
        return { cx: b.x + b.w / 2, cy: b.y + b.h / 2 };
      }

      function renderNode(n) {
        let el = document.getElementById(n.id);
        if (!el) {
          el = document.createElement("div");
          el.className = "node node--" + n.type;
          el.id = n.id;
          el.innerHTML = `
            <div class="node__title editable-hint" contenteditable="false" data-placeholder="Untitled"></div>
            <div class="node__content"></div>
            <div class="node__ports"><div class="node__port"></div></div>
          `;
          boardEl.appendChild(el);

          // add resize handle
          const resizer = document.createElement("div");
          resizer.className = "node__resizer";
          el.appendChild(resizer);

          let resizing = false;
          let startW = 0,
            startH = 0,
            startX = 0,
            startY = 0;
          resizer.addEventListener("mousedown", (ev) => {
            ev.stopPropagation();
            resizing = true;
            startX = ev.clientX;
            startY = ev.clientY;
            startW = el.offsetWidth;
            startH = el.offsetHeight;
            document.body.style.userSelect = "none";
          });
          window.addEventListener("mousemove", (ev) => {
            if (!resizing) return;
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;

            const maxW = 640,
              maxH = 600;
            const baseMinW = 160,
              baseMinH = 80;

            // Desired width from drag, clamped to base min/max
            let nextW = Math.max(
              baseMinW,
              Math.min(maxW, Math.round(startW + dx))
            );
            // Apply width first to let text wrap and images scale, then measure content height
            el.style.width = nextW + "px";
            el.style.height = "auto";

            // Content-required height (includes title, content, tags, ports, etc.)
            const contentMinH = Math.ceil(el.scrollHeight);

            // Desired height from drag, but never below content-required height
            let nextH = Math.max(
              baseMinH,
              Math.min(maxH, Math.round(startH + dy))
            );
            nextH = Math.max(nextH, contentMinH);

            // Commit
            n.w = nextW;
            n.h = nextH;
            el.style.height = nextH + "px";

            updateBoardExtent();
            renderEdges();
          });
          window.addEventListener("mouseup", () => {
            if (!resizing) return;
            resizing = false;
            document.body.style.userSelect = "";
            markDirty();
            updateSaveButton();
          });

          // select on click
          el.addEventListener("mousedown", (ev) => {
            if (ev.target && ev.target.closest(".node__resizer")) return;
            // if connect mode, handle port click like connection
            if (connectMode) {
              if (!connectFromId) {
                connectFromId = n.id;
                showStatus("Source selected. Pick a target.", { ttl: 2200 });
                renderGhostEdge();
              } else {
                addEdge(connectFromId, n.id);
                connectFromId = null;
                hideGhost();
                showStatus("Connected.", { ttl: 1800 });
              }
              ev.stopPropagation();
              return;
            }
            selectedEdgeId = null;
            selectedNodeId = n.id;
            updateSelections();
          });
          // right-click to open context menu for this node
          el.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            selectedEdgeId = null;
            selectedNodeId = n.id;
            updateSelections();
            // show menu at mouse position
            showContextMenu(ev.clientX, ev.clientY, { type: "node", id: n.id });
          });
          // drag
          let dragging = false,
            offX = 0,
            offY = 0;
          el.addEventListener("mousedown", (ev) => {
            if (ev.target && ev.target.closest(".node__resizer")) return;
            dragging = true;
            offX = ev.clientX - n.x;
            offY = ev.clientY - n.y;
          });
          window.addEventListener("mousemove", (ev) => {
            if (!dragging) return;
            n.x = ev.clientX - offX;
            n.y = ev.clientY - offY;
            el.style.left = n.x + "px";
            el.style.top = n.y + "px";
            updateBoardExtent();
            renderEdges(); // update edge positions live
          });
          window.addEventListener("mouseup", () => {
            if (dragging) {
              dragging = false;
              markDirty();
              updateSaveButton();
            }
          });

          // inline edits
          const titleEl = el.querySelector(".node__title");
          titleEl.addEventListener("input", () => {
            n.data.title = titleEl.textContent || "";
            markDirty();
            updateBoardExtent();
            renderEdges(); // keep connections glued to borders as size changes
          });
          // Make title editable only after a double-click
          let _preEditTitle = null;
          function placeCaretAtEnd(node) {
            const r = document.createRange();
            r.selectNodeContents(node);
            r.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(r);
          }
          titleEl.addEventListener("dblclick", (ev) => {
            ev.stopPropagation();
            _preEditTitle = titleEl.textContent;
            titleEl.setAttribute("contenteditable", "true");
            // focus at end
            setTimeout(() => {
              titleEl.focus();
              placeCaretAtEnd(titleEl);
            }, 0);
          });
          // Press Enter to commit, Esc to cancel
          titleEl.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
              ev.preventDefault();
              titleEl.blur();
            } else if (ev.key === "Escape") {
              ev.preventDefault();
              if (_preEditTitle != null) titleEl.textContent = _preEditTitle;
              titleEl.blur();
            }
          });
          titleEl.addEventListener("blur", () => {
            // When leaving edit mode, lock it back
            titleEl.setAttribute("contenteditable", "false");
            _preEditTitle = null;
          });
          el.addEventListener("dblclick", (ev) => {
            if (n.type === "text") {
              // Focus the rich editor instead of opening a prompt
              const rich = el.querySelector(".rich");
              if (rich) {
                rich.focus();
              }
              return; // no prompt
            }

            if (n.type === "image") {
              // Only trigger URL edit when the actual image is double-clicked
              const imgEl = ev.target && ev.target.closest("img");
              if (!imgEl || !el.contains(imgEl)) return; // ignore dblclicks elsewhere in the node
              const url = prompt("Edit image URL:", n.data.imageUrl ?? "");
              if (url !== null) n.data.imageUrl = url;
              renderNode(n);
              renderEdges();
              markDirty();
              return;
            }
          });
        }

        el.style.left = n.x + "px";
        el.style.top = n.y + "px";
        if (n.w) el.style.width = n.w + "px";
        else el.style.removeProperty("width");
        if (n.h) el.style.height = n.h + "px";
        else el.style.removeProperty("height");
        el.classList.toggle("selected", selectedNodeId === n.id);
        // Ensure node type modifier class follows BEM: node--{type}
        el.classList.forEach((c) => {
          if (
            (c.startsWith("node-") || c.startsWith("node--")) &&
            c !== "node"
          ) {
            el.classList.remove(c);
          }
        });
        el.classList.add("node--" + n.type);

        const titleEl = el.querySelector(".node__title");
        titleEl.setAttribute(
          "data-placeholder",
          n.type === "text"
            ? "Text title"
            : n.type === "image"
            ? "Image title"
            : "Link title"
        );
        // Preserve existing title; allow empty to show placeholder
        titleEl.textContent =
          typeof n.data.title === "string"
            ? n.data.title
            : n.type === "text"
            ? "Text"
            : n.type === "image"
            ? "Image"
            : "Link";

        const contentEl = el.querySelector(".node__content");
        if (n.type === "text") {
          const html =
            n.data.html ?? (n.data.text ? escapeHtml(n.data.text) : "");
          contentEl.innerHTML = `
            <div class="rtb" role="toolbar" aria-label="Text formatting">
              <button data-cmd="bold" title="Bold">B</button>
              <button data-cmd="italic" title="Italic"><i>I</i></button>
              <button data-cmd="underline" title="Underline"><u>U</u></button>
              <button data-cmd="insertUnorderedList" title="Bullet list">â€¢â€¢</button>
              <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
              <button data-action="link" title="Insert link">ðŸ”—</button>
              <button data-action="clear" title="Clear formatting">â¨¯</button>
            </div>
            <div class="rich" contenteditable="true" data-placeholder="Type textâ€¦">${html}</div>`;
        } else if (n.type === "image") {
          const desc = n.data.descHtml ?? "";
          contentEl.innerHTML = n.data.imageUrl
            ? `<img src="${escapeAttr(n.data.imageUrl)}" alt="">` +
              (() => {
                const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
                const wrapDisplay = hasDesc ? "" : 'style="display:none"';
                const addBtn = hasDesc
                  ? ""
                  : `<button class="add-desc" type="button">+ Add description</button>`;
                return `
                  ${addBtn}
                  <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                    <button data-cmd="bold" title="Bold">B</button>
                    <button data-cmd="italic" title="Italic"><i>I</i></button>
                    <button data-cmd="underline" title="Underline"><u>U</u></button>
                    <button data-cmd="insertUnorderedList" title="Bullet list">â€¢â€¢</button>
                    <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                    <button data-action="link" title="Insert link">ðŸ”—</button>
                    <button data-action="clear" title="Clear formatting">â¨¯</button>
                  </div>
                  <div class="rich" contenteditable="true" data-field="descHtml" data-placeholder="Add a descriptionâ€¦" ${wrapDisplay}>${
                  n.data.descHtml ?? ""
                }</div>
                `;
              })()
            : `<em>No image</em>`;
          // Wire up Add description toggler
          const addDescBtn = el.querySelector(".add-desc");
          if (addDescBtn) {
            addDescBtn.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const rtb = el.querySelector(".rtb");
              const rich = el.querySelector('.rich[data-field="descHtml"]');
              if (rtb) rtb.style.display = "";
              if (rich) rich.style.display = "";
              addDescBtn.remove();
            });
          }
        } else if (n.type === "link") {
          const u = n.data.linkUrl ?? "";
          const desc = n.data.descHtml ?? "";
          if (!u) {
            contentEl.innerHTML = `<em>No link</em>`;
          } else if (n.data.preview) {
            const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
            const wrapDisplay = hasDesc ? "" : 'style="display:none"';
            const addBtn = hasDesc
              ? ""
              : `<button class="add-desc" type="button">+ Add description</button>`;
            contentEl.innerHTML =
              renderLinkCard(n.data.preview, u) +
              `${addBtn}
               <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                 <button data-cmd="bold" title="Bold">B</button>
                 <button data-cmd="italic" title="Italic"><i>I</i></button>
                 <button data-cmd="underline" title="Underline"><u>U</u></button>
                 <button data-cmd="insertUnorderedList" title="Bullet list">â€¢â€¢</button>
                 <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                 <button data-action="link" title="Insert link">ðŸ”—</button>
                 <button data-action="clear" title="Clear formatting">â¨¯</button>
               </div>
               <div class="rich" contenteditable="true" data-field="descHtml" data-placeholder="Add a descriptionâ€¦" ${wrapDisplay}>${desc}</div>`;
          } else {
            // initial minimal view while loading
            const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
            const wrapDisplay = hasDesc ? "" : 'style="display:none"';
            const addBtn = hasDesc
              ? ""
              : `<button class="add-desc" type="button">+ Add description</button>`;
            contentEl.innerHTML =
              `<a href="${escapeAttr(
                u
              )}" target="_blank" rel="noopener">${escapeHtml(u)}</a>` +
              `<div style="margin-top:6px;color:#9ca3af;font-size:12px;">Loading previewâ€¦</div>` +
              `${addBtn}
               <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                 <button data-cmd="bold" title="Bold">B</button>
                 <button data-cmd="italic" title="Italic"><i>I</i></button>
                 <button data-cmd="underline" title="Underline"><u>U</u></button>
                 <button data-cmd="insertUnorderedList" title="Bullet list">â€¢â€¢</button>
                 <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                 <button data-action="link" title="Insert link">ðŸ”—</button>
                 <button data-action="clear" title="Clear formatting">â¨¯</button>
               </div>
               <div class="rich" contenteditable="true" data-field="descHtml" data-placeholder="Add a descriptionâ€¦" ${wrapDisplay}>${desc}</div>`;
            // kick off preview fetch (once)
            (async () => {
              const p = await fetchLinkPreview(u);
              if (p) {
                n.data.preview = p;
                markDirty();
                renderNode(n);
                renderEdges();
              }
            })();
          }
          // Wire up Add description toggler for Link
          const addDescBtnL = el.querySelector(".add-desc");
          if (addDescBtnL) {
            addDescBtnL.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const rtb = el.querySelector(".rtb");
              const rich = el.querySelector('.rich[data-field="descHtml"]');
              if (rtb) rtb.style.display = "";
              if (rich) rich.style.display = "";
              addDescBtnL.remove();
            });
          }
        }

        // Tags UI (common to all types)
        let tagsWrap = el.querySelector(".tags");
        if (!tagsWrap) {
          tagsWrap = document.createElement("div");
          tagsWrap.className = "tags";
          el.querySelector(".node__content").appendChild(tagsWrap);
        }
        renderTagChips(n, tagsWrap);

        let addTagBtn = el.querySelector(".add-tag");
        if (!addTagBtn) {
          addTagBtn = document.createElement("button");
          addTagBtn.className = "add-tag";
          addTagBtn.textContent = "+ tag";
          el.querySelector(".node__content").appendChild(addTagBtn);
          addTagBtn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            const input = prompt("Add tags (comma separated or single #tag):");
            if (!input) return;
            const parts = input
              .split(",")
              .map((s) => normalizeTag(s))
              .filter(Boolean);
            const tags = ensureTags(n);
            for (const t of parts) {
              if (!tags.includes(t)) tags.push(t);
            }
            renderTagChips(n, tagsWrap);
            markDirty();
          });
        }
        // Attach rich text toolbar listeners (Text uses data.html; Image/Link use data.descHtml)
        {
          const rtb = el.querySelector(".rtb");
          const rich = el.querySelector(".rich");
          if (rtb && rich) {
            const field = n.type === "text" ? "html" : "descHtml";
            const isOptionalDesc =
              field === "descHtml" && (n.type === "image" || n.type === "link");

            function ensureAddDescButton() {
              if (!isOptionalDesc) return;
              let addBtn = el.querySelector(".add-desc");
              if (!addBtn) {
                addBtn = document.createElement("button");
                addBtn.className = "add-desc";
                addBtn.type = "button";
                addBtn.textContent = "+ Add description";
                addBtn.addEventListener("click", (ev) => {
                  ev.stopPropagation();
                  if (rtb) rtb.style.display = "";
                  if (rich) rich.style.display = "";
                  addBtn.remove();
                  rich.focus();
                });
                el.querySelector(".node__content").insertBefore(addBtn, rtb);
              }
            }

            function maybeCollapseIfEmpty() {
              if (!isOptionalDesc) return;
              const plain = (rich.textContent || "").trim();
              const has = plain.length > 0;
              if (!has) {
                // clear stored value and collapse UI
                n.data.descHtml = "";
                if (rtb) rtb.style.display = "none";
                if (rich) {
                  rich.style.display = "none";
                  rich.innerHTML = "";
                }
                ensureAddDescButton();
              }
            }

            // Keep focus inside editor when clicking toolbar
            rtb.addEventListener("mousedown", (ev) => {
              ev.preventDefault();
              rich.focus();
            });
            rtb.addEventListener("click", (ev) => {
              const btn = ev.target.closest("button");
              if (!btn) return;
              const cmd = btn.getAttribute("data-cmd");
              const act = btn.getAttribute("data-action");
              rich.focus();
              if (cmd) {
                document.execCommand(cmd, false, null);
                n.data[field] = rich.innerHTML;
                markDirty();
                renderEdges();
                maybeCollapseIfEmpty();
              } else if (act === "link") {
                const url = prompt("Link URL", "https://");
                if (url) document.execCommand("createLink", false, url);
                n.data[field] = rich.innerHTML;
                markDirty();
                maybeCollapseIfEmpty();
              } else if (act === "clear") {
                document.execCommand("removeFormat");
                const a = rich.querySelector("a");
                if (a) {
                  const t = document.createTextNode(a.textContent || "");
                  a.replaceWith(t);
                }
                rich.innerHTML = "";
                n.data[field] = "";
                markDirty();
                maybeCollapseIfEmpty();
              }
            });

            const syncHtml = () => {
              n.data[field] = rich.innerHTML;
              markDirty();
              maybeCollapseIfEmpty();
            };
            rich.addEventListener("input", syncHtml);
            rich.addEventListener("blur", syncHtml);
          }
        }
        // Toggle resizer visibility based on node type (text, image, link are resizable)
        const resizerEl = el.querySelector(".node__resizer");
        if (resizerEl) {
          resizerEl.style.display =
            n.type === "text" || n.type === "image" || n.type === "link"
              ? ""
              : "none";
        }
      }

      function renderNodes() {
        // Remove DOM nodes that no longer exist in data
        const ids = new Set(board.nodes.map((n) => n.id));
        document.querySelectorAll(".node").forEach((el) => {
          if (!ids.has(el.id)) el.remove();
        });
        board.nodes.forEach(renderNode);
      }

      // Compute an anchor point on the boundary of node n that faces (ox, oy)
      function anchorPoint(n, ox, oy) {
        const b = nodeBounds(n);
        const cx = b.x + b.w / 2;
        const cy = b.y + b.h / 2;
        const dx = ox - cx;
        const dy = oy - cy;

        // Choose side by dominant axis
        if (Math.abs(dx) > Math.abs(dy)) {
          // left/right
          if (dx >= 0) {
            return { x: b.x + b.w, y: cy, side: "right" };
          } else {
            return { x: b.x, y: cy, side: "left" };
          }
        } else {
          // top/bottom
          if (dy >= 0) {
            return { x: cx, y: b.y + b.h, side: "bottom" };
          } else {
            return { x: cx, y: b.y, side: "top" };
          }
        }
      }

      // Build a synthetic â€œtargetâ€ anchor at the mouse so the curve bends nicely.
      // We pick the side opposite to where the mouse is relative to the source node,
      // so control points push outward (pleasant S-curve).
      function mouseAnchor(fromNode, mx, my) {
        const b = nodeBounds(fromNode);
        const cx = b.x + (b.w || 0) / 2;
        const cy = b.y + (b.h || 0) / 2;
        const dx = mx - cx;
        const dy = my - cy;
        let side;
        if (Math.abs(dx) > Math.abs(dy)) {
          side = dx >= 0 ? "left" : "right"; // opposite of mouse horizontal side
        } else {
          side = dy >= 0 ? "top" : "bottom"; // opposite of mouse vertical side
        }
        return { x: mx, y: my, side };
      }

      // Smooth cubic path between two anchors, with curvature adaptive to distance
      function smoothCubic(a, b) {
        const x1 = a.x,
          y1 = a.y,
          x2 = b.x,
          y2 = b.y;
        const dx = Math.abs(x2 - x1);
        const dy = Math.abs(y2 - y1);
        const d = Math.max(dx, dy);
        const c = Math.min(160, Math.max(40, d * 0.6)); // curvature

        let c1x = x1,
          c1y = y1,
          c2x = x2,
          c2y = y2;

        // Push control points outward from each side
        switch (a.side) {
          case "right":
            c1x += c;
            break;
          case "left":
            c1x -= c;
            break;
          case "top":
            c1y -= c;
            break;
          case "bottom":
            c1y += c;
            break;
        }
        switch (b.side) {
          case "right":
            c2x -= c;
            break;
          case "left":
            c2x += c;
            break;
          case "top":
            c2y += c;
            break;
          case "bottom":
            c2y -= c;
            break;
        }

        return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
      }

      function computeContentExtent(pad = 160) {
        let maxX = 0,
          maxY = 0;
        for (const n of board.nodes) {
          const b = nodeBounds(n);
          const w = b.w || 240;
          const h = b.h || 100;
          maxX = Math.max(maxX, b.x + w);
          maxY = Math.max(maxY, b.y + h);
        }
        const rect = boardEl.getBoundingClientRect();
        const w = Math.max(maxX + pad, rect.width);
        const h = Math.max(maxY + pad, rect.height);
        return { w, h };
      }

      function updateBoardExtent() {
        const { w, h } = computeContentExtent(160);
        const sizer = document.getElementById("boardSizer");
        if (sizer) {
          sizer.style.width = w + "px";
          sizer.style.height = h + "px";
        }
        edgesSvg.setAttribute("width", w);
        edgesSvg.setAttribute("height", h);
        edgesSvg.style.width = w + "px";
        edgesSvg.style.height = h + "px";
      }

      function renderEdges() {
        edgesSvg.innerHTML = "";
        updateBoardExtent();
        if (!visibleNodeIds) {
          visibleNodeIds = new Set(board.nodes.map((n) => n.id));
        }

        for (const e of board.edges) {
          const s = board.nodes.find((n) => n.id === e.sourceId);
          const t = board.nodes.find((n) => n.id === e.targetId);
          if (!s || !t) continue;
          if (!visibleNodeIds.has(s.id) || !visibleNodeIds.has(t.id)) continue;
          const sc = centerOf(s);
          const tc = centerOf(t);
          const a1 = anchorPoint(s, tc.cx, tc.cy);
          const a2 = anchorPoint(t, sc.cx, sc.cy);
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.setAttribute("data-id", e.id);

          // Path
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute("d", smoothCubic(a1, a2));
          let cls = "edge" + (selectedEdgeId === e.id ? " edge--selected" : "");
          if (e.dashed) cls += " edge--dashed";
          path.setAttribute("class", cls);
          if (e.color) {
            // Use inline style so it overrides the .edge CSS rule
            path.style.stroke = e.color;
          } else {
            path.style.stroke = null; // fall back to CSS (.edge { stroke: red; })
          }
          path.dataset.id = e.id;

          // Label (optional)
          if (e.label) {
            const tx = (a1.x + a2.x) / 2;
            const ty = (a1.y + a2.y) / 2 - 2; // closer to the curve
            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            text.setAttribute("x", tx);
            text.setAttribute("y", ty);
            text.setAttribute("class", "edge__label");
            text.textContent = e.label;

            // Click/ctx on label behave like the edge
            text.addEventListener("click", (ev) => {
              selectedNodeId = null;
              selectedEdgeId = e.id;
              updateSelections();
              ev.stopPropagation();
              return false;
            });
            text.addEventListener("contextmenu", (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              selectedNodeId = null;
              selectedEdgeId = e.id;
              updateSelections();
              showContextMenu(ev.clientX, ev.clientY, {
                type: "edge",
                id: e.id,
              });
              return false;
            });
            g.appendChild(text);
          }

          // Events on path
          path.addEventListener("click", (ev) => {
            selectedNodeId = null;
            selectedEdgeId = e.id;
            updateSelections();
            ev.stopPropagation();
            return false;
          });
          path.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            selectedNodeId = null;
            selectedEdgeId = e.id;
            updateSelections();
            showContextMenu(ev.clientX, ev.clientY, { type: "edge", id: e.id });
            return false;
          });

          g.appendChild(path);

          // Add endpoint circles
          const startCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          startCircle.setAttribute("cx", a1.x);
          startCircle.setAttribute("cy", a1.y);
          startCircle.setAttribute("r", "4");
          startCircle.setAttribute("class", "edge__endpoint");

          const endCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          endCircle.setAttribute("cx", a2.x);
          endCircle.setAttribute("cy", a2.y);
          endCircle.setAttribute("r", "4");
          endCircle.setAttribute("class", "edge__endpoint");

          g.appendChild(startCircle);
          g.appendChild(endCircle);

          edgesSvg.appendChild(g);
        }
        // Re-draw ghost on top if we're mid-connection
        if (connectMode && connectFromId) {
          renderGhostEdge();
        } else {
          hideGhost();
        }
      }

      function updateSelections() {
        // nodes
        document.querySelectorAll(".node").forEach((el) => {
          el.classList.toggle("selected", el.id === selectedNodeId);
        });
        // edges
        document.querySelectorAll("path.edge").forEach((p) => {
          p.classList.toggle("edge--selected", p.dataset.id === selectedEdgeId);
        });
      }

      function render() {
        renderNodes();
        renderEdges();
        applySearchFilter();
        adjustBoardHeight();
      }

      function escapeHtml(s) {
        return (s ?? "").toString().replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function escapeAttr(s) {
        return escapeHtml(s);
      }

      function ensureTags(n) {
        if (!n.data) n.data = {};
        if (!Array.isArray(n.data.tags)) n.data.tags = [];
        return n.data.tags;
      }
      function normalizeTag(t) {
        return (t || "").toString().trim().replace(/^#+/, "").toLowerCase();
      }
      function renderTagChips(n, hostEl) {
        const tags = ensureTags(n);
        hostEl.innerHTML = "";
        for (let i = 0; i < tags.length; i++) {
          const tag = tags[i];
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.innerHTML = `<span>#${escapeHtml(
            tag
          )}</span> <button title="Remove tag" data-i="${i}">âœ•</button>`;
          chip.querySelector("button").addEventListener("click", (ev) => {
            ev.stopPropagation();
            tags.splice(i, 1);
            renderTagChips(n, hostEl);
            markDirty();
          });
          hostEl.appendChild(chip);
        }
      }

      function plainTextFromHtml(html) {
        const tmp = document.createElement("div");
        tmp.innerHTML = html || "";
        return (tmp.textContent || tmp.innerText || "").trim();
      }

      let currentQuery = "";
      let visibleNodeIds = null; // Set<string>

      function parseQuery(q) {
        const parts = (q || "").trim().split(/\\s+/).filter(Boolean);
        const tags = [];
        const terms = [];
        for (const p of parts) {
          if (p.startsWith("#")) tags.push(normalizeTag(p));
          else terms.push(p.toLowerCase());
        }
        return { tags, terms };
      }

      function nodeMatches(n, q) {
        if (!q || (!q.tags.length && !q.terms.length)) return true;
        const tags = ensureTags(n);
        // tag logic: all query tags must be present
        for (const t of q.tags) {
          if (!tags.map(normalizeTag).includes(t)) return false;
        }
        if (!q.terms.length) return true;
        const hay = [
          n.data?.title || "",
          n.data?.text || "",
          plainTextFromHtml(n.data?.html || ""),
          n.data?.linkUrl || "",
          tags.join(" "),
        ]
          .join(" ")
          .toLowerCase();
        return q.terms.every((term) => hay.includes(term));
      }

      function applySearchFilter() {
        const q = parseQuery(currentQuery);
        visibleNodeIds = new Set();
        for (const n of board.nodes) {
          const el = document.getElementById(n.id);
          const match = nodeMatches(n, q);
          if (el) {
            el.style.display = match ? "" : "none";
            el.classList.toggle("dim", !match && currentQuery.length > 0);
          }
          if (match) visibleNodeIds.add(n.id);
        }
        renderEdges();
      }

      function exportBoard() {
        // Let the server stream a ZIP (includes board.json and uploads/)
        showStatus("Export in progressâ€¦", { sticky: true });
        // Trigger the download
        window.location.href = `/api/board/${encodeURIComponent(
          window.__globals.board.id
        )}/export`;
        // After a short delay, update the message to guide user
        setTimeout(() => {
          showStatus(
            "Export initiated. Please check your downloads folder once it completes.",
            { sticky: true }
          );
        }, 500);
      }

      async function fetchLinkPreview(url) {
        try {
          const resp = await fetch("/api/link-preview", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ url }),
          });
          if (!resp.ok) throw new Error("Failed");
          return await resp.json();
        } catch (e) {
          return null;
        }
      }

      function renderLinkCard(preview, href) {
        const title = escapeHtml(preview?.title || href || "Link");
        const desc = escapeHtml(preview?.description || "");
        const site = escapeHtml(
          preview?.siteName || (href ? new URL(href).hostname : "")
        );
        const icon = preview?.icon
          ? `<img class="icon" src="${escapeAttr(preview.icon)}" alt="">`
          : "";
        const img = preview?.image
          ? `<img class="thumb" src="${escapeAttr(preview.image)}" alt="">`
          : `<div class="thumb"></div>`;
        const safeHref = escapeAttr(href || preview?.url || "#");
        return `
          <a href="${safeHref}" target="_blank" rel="noopener" class="link-card">
            ${img}
            <div class="meta">
              <div class="title">${title}</div>
              ${desc ? `<div class="desc">${desc}</div>` : ""}
              <div class="site">${icon}${site}</div>
            </div>
          </a>
        `;
      }

      function validateImported(json) {
        if (!json || typeof json !== "object")
          throw new Error("File is not a JSON object");
        if (!Array.isArray(json.nodes) || !Array.isArray(json.edges))
          throw new Error("Missing nodes/edges arrays");
        // Minimal normalization: ensure required fields exist
        json.id = json.id || "board-1";
        json.title = json.title || "Imported Board";
        json.createdAt = json.createdAt || new Date().toISOString();
        json.updatedAt = new Date().toISOString();
        json.nodes = json.nodes.map((n, i) => ({
          id: n.id || `n_imp_${i}`,
          type: n.type || "text",
          x: Number.isFinite(n.x) ? n.x : 100 + i * 20,
          y: Number.isFinite(n.y) ? n.y : 100 + i * 20,
          w: n.w,
          h: n.h,
          data: n.data || {},
        }));
        json.edges = json.edges
          .filter((e) => e && e.sourceId && e.targetId)
          .map((e, i) => ({
            id: e.id || `e_imp_${i}`,
            sourceId: e.sourceId,
            targetId: e.targetId,
          }));
        return json;
      }

      // --- Auto-layout (simple layered layout, dagre-like) ---
      function buildGraph() {
        const nodes = board.nodes.map((n) => ({ id: n.id }));
        const edges = board.edges.map((e) => ({
          from: e.sourceId,
          to: e.targetId,
        }));
        const adj = new Map();
        const indeg = new Map();
        for (const n of nodes) {
          adj.set(n.id, []);
          indeg.set(n.id, 0);
        }
        for (const e of edges) {
          if (!adj.has(e.from)) adj.set(e.from, []);
          adj.get(e.from).push(e.to);
          if (indeg.has(e.to)) indeg.set(e.to, indeg.get(e.to) + 1);
          else indeg.set(e.to, 1);
        }
        return { nodes, edges, adj, indeg };
      }

      function topoLayers() {
        const { nodes, adj, indeg } = buildGraph();
        const q = [];
        const indegCopy = new Map(indeg);
        for (const n of nodes)
          if ((indegCopy.get(n.id) || 0) === 0) q.push(n.id);
        const layers = [];
        const placed = new Set();
        // Kahn-like layering: nodes with indegree==0 form layer 0, then peel
        let current = q.slice();
        let visitedCount = 0;
        while (current.length) {
          layers.push(current);
          const next = [];
          for (const id of current) {
            placed.add(id);
            visitedCount++;
            const outs = adj.get(id) || [];
            for (const v of outs) {
              indegCopy.set(v, (indegCopy.get(v) || 0) - 1);
              if (indegCopy.get(v) === 0) next.push(v);
            }
          }
          current = next;
        }
        // Any remaining nodes are in cycles; place them in subsequent layers by a simple BFS from any unplaced
        if (visitedCount < nodes.length) {
          const rest = nodes.map((n) => n.id).filter((id) => !placed.has(id));
          // group into chunks of up to 5 per layer to avoid stacking all in one
          const chunk = 5;
          for (let i = 0; i < rest.length; i += chunk)
            layers.push(rest.slice(i, i + chunk));
        }
        return layers;
      }

      function autoLayout(direction = "LR") {
        if (!board.nodes.length) return;
        // Ensure DOM sizes are measured before layout
        renderNodes();
        // Build layered structure
        const layers = topoLayers();
        const layerGap = 180; // distance between layers
        const nodeGap = 80; // distance between nodes within a layer

        // Precompute sizes
        const size = new Map();
        for (const n of board.nodes) {
          const b = nodeBounds(n);
          size.set(n.id, { w: b.w || 240, h: b.h || 100 });
        }

        if (direction === "LR") {
          // Layers progress left-to-right; within each layer, nodes are stacked vertically
          let x = 80;
          for (const layer of layers) {
            // compute max width in this layer
            let maxW = 0;
            for (const id of layer) {
              maxW = Math.max(maxW, size.get(id)?.w || 240);
            }
            // vertical placement centered around the board's current view
            let y = 80;
            for (const id of layer) {
              const n = board.nodes.find((nn) => nn.id === id);
              if (!n) continue;
              const wh = size.get(id) || { w: 240, h: 100 };
              n.x = x;
              n.y = y;
              y += wh.h + nodeGap;
            }
            x += maxW + layerGap;
          }
        } else {
          // TB top-to-bottom
          let y = 80;
          for (const layer of layers) {
            let maxH = 0;
            for (const id of layer) {
              maxH = Math.max(maxH, size.get(id)?.h || 100);
            }
            let x = 80;
            for (const id of layer) {
              const n = board.nodes.find((nn) => nn.id === id);
              if (!n) continue;
              const wh = size.get(id) || { w: 240, h: 100 };
              n.x = x;
              n.y = y;
              x += wh.w + nodeGap;
            }
            y += maxH + layerGap;
          }
        }
        render();
        markDirty();
        setStatus("Auto-layout applied");
      }

      // Ensure status bar hint is rendered on first load
      renderStatusBar();
      adjustBoardHeight();

      function openAbout() {
        document.getElementById("aboutAppVersion").textContent =
          window.__globals.appVersion;
        document.getElementById("aboutSchemaVersion").textContent = String(
          board.schemaVersion || 1
        );
        document.getElementById("aboutBoardName").textContent =
          board.title || "Untitled Board";
        aboutModal.classList.add("show");
      }
      function closeAbout() {
        aboutModal.classList.remove("show");
      }

      // Toolbar wiring
      $("#addText").onclick = () =>
        addNode("text", viewCenter(), { text: "New note..." });
      $("#addImage").onclick = () => addNode("image", viewCenter());
      $("#addLink").onclick = () => addNode("link", viewCenter());
      $("#connect").onclick = toggleConnectMode;
      document.getElementById("autoLayout").onclick = () => autoLayout("LR");
      exportBtn.onclick = exportBoard;
      importBtn.onclick = () => importFile.click();
      infoBtn.addEventListener("click", openAbout);
      aboutClose.addEventListener("click", closeAbout);
      aboutModal.addEventListener("click", (e) => {
        if (e.target === aboutModal) closeAbout();
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (aboutModal.classList.contains("show")) closeAbout();
          if (connectMode && connectFromId) {
            connectFromId = null;
            hideGhost();
            showStatus("Connect cancelled");
          }
        }
      });

      boardEl.addEventListener("mousedown", (ev) => {
        if (!ev.target || ev.target === boardEl) {
          if (connectMode && connectFromId) {
            connectFromId = null;
            hideGhost();
            showStatus("Connect cancelled");
          }
        }
      });
      importFile.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          if (/\.zip$/i.test(file.name)) {
            // Probe first
            const probeFd = new FormData();
            probeFd.append("bundle", file);
            const probeResp = await fetch(
              `/api/board/${encodeURIComponent(
                window.__globals.board.id
              )}/validate-import`,
              {
                method: "POST",
                body: probeFd,
              }
            );
            if (!probeResp.ok)
              throw new Error(`Probe failed (${probeResp.status})`);
            const meta = await probeResp.json();

            if (meta.boardId === board.id) {
              const ok = confirm(
                `You're importing the SAME board (ID: ${
                  meta.boardId
                }).\nTitle: ${
                  meta.title || "(untitled)"
                }\nReplace the current board with the imported one?`
              );
              if (!ok) {
                setStatus("Import cancelled.");
                importFile.value = "";
                return;
              }
            }

            setStatus("Importing zipâ€¦");
            const fd = new FormData();
            fd.append("bundle", file);
            const resp = await fetch(
              `/api/board/${encodeURIComponent(
                window.__globals.board.id
              )}/import`,
              {
                method: "POST",
                body: fd,
              }
            );
            if (!resp.ok) throw new Error(`Import failed (${resp.status})`);
            const json = await resp.json();
            board = json;
            render();
            markDirty();
            setStatus(`Imported ${file.name}`);
          } else {
            const text = await file.text();
            const json = JSON.parse(text);
            const validated = validateImported(json);
            if (validated.id === board.id) {
              const ok = confirm(
                `You're importing the SAME board (ID: ${validated.id}). Replace the current board with the imported one?`
              );
              if (!ok) {
                setStatus("Import cancelled.");
                importFile.value = "";
                return;
              }
            }
            board = validated;
            render();
            markDirty();
            setStatus(`Imported ${file.name}`);
          }
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
          setStatus("Import failed.");
        } finally {
          importFile.value = "";
        }
      });
      // Search wiring (debounced + clear)
      let searchTimer = null;
      const clearSearchBtn = document.getElementById("clearSearch");
      const updateClearBtn = () => {
        clearSearchBtn.disabled = !searchInput.value;
      };
      updateClearBtn();

      searchInput.addEventListener("input", (e) => {
        currentQuery = e.target.value || "";
        if (searchTimer) clearTimeout(searchTimer);
        searchTimer = setTimeout(() => applySearchFilter(), 150);
        updateClearBtn();
      });

      // Allow Esc to clear search without triggering global handlers
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          searchInput.value = "";
          currentQuery = "";
          applySearchFilter();
          updateClearBtn();
          e.stopPropagation();
        }
      });

      // Clear button
      clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        currentQuery = "";
        applySearchFilter();
        updateClearBtn();
        searchInput.focus();
      });
      $("#save").onclick = saveBoard;
      $("#reset").onclick = resetBoard;

      function viewCenter() {
        const rect = boardEl.getBoundingClientRect();
        return {
          x: boardEl.scrollLeft + rect.width / 2 - 120,
          y: boardEl.scrollTop + rect.height / 2 - 60,
        };
      }

      /** Info Button */
      function openAbout() {
        document.getElementById("aboutAppVersion").textContent =
          window.__globals.appVersion;
        document.getElementById("aboutSchemaVersion").textContent = String(
          board.schemaVersion || 1
        );
        document.getElementById("aboutBoardName").textContent =
          board.title || "Untitled Board";
        aboutModal.classList.add("show");
      }

      function closeAbout() {
        aboutModal.classList.remove("show");
      }

      infoBtn.addEventListener("click", openAbout);
      aboutClose.addEventListener("click", closeAbout);
      // Close when clicking the backdrop
      aboutModal.addEventListener("click", (e) => {
        if (e.target === aboutModal) closeAbout();
      });
      // Close on Esc
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && aboutModal.classList.contains("show"))
          closeAbout();
      });
      /** end of Info Button */

      function toggleConnectMode() {
        connectMode = !connectMode;
        connectFromId = null;
        setConnectMode(connectMode);
      }

      document.addEventListener("keydown", (e) => {
        const typing = isTypingTarget(e.target);

        if (!typing && (e.key === "Delete" || e.key === "Backspace")) {
          e.preventDefault(); // avoid browser back
          removeSelection();
          return;
        }
        if (!typing && e.key.toLowerCase() === "c") {
          toggleConnectMode();
          return;
        }
        if (e.key.toLowerCase() === "l" && (e.metaKey || e.ctrlKey)) {
          e.preventDefault();
          autoLayout("LR");
        }
      });

      // click blank space to clear selection
      boardEl.addEventListener("mousedown", (ev) => {
        if (ev.target === boardEl || ev.target === edgesSvg) {
          hideContextMenu();
          selectedNodeId = null;
          selectedEdgeId = null;
          updateSelections();
        }
      });
      // Allow dropping a .json file onto the board to import
      boardEl.addEventListener("dragover", (e) => {
        e.preventDefault();
      });
      boardEl.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer?.files?.[0];
        if (!file || !file.name.toLowerCase().endsWith(".json")) return;
        try {
          const text = await file.text();
          const json = JSON.parse(text);
          const validated = validateImported(json);
          board = validated;
          render();
          markDirty();
          setStatus(`Imported ${file.name}`);
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
          setStatus("Import failed.");
        }
      });

      // Load existing board
      async function loadBoard() {
        try {
          const resp = await fetch(
            `/api/board/${encodeURIComponent(window.__globals.board.id)}`
          );
          const data = await resp.json();
          board = data;
          render();
          boardNameEl.textContent = board.title || "";
          lastSavedJSON = computeSnapshot();
          updateSaveButton();
          currentQuery = searchInput.value || "";
          applySearchFilter();
          setStatus("Loaded.");
          renderStatusBar();
        } catch (e) {
          setStatus("No saved board yet. Start adding nodes.");
          renderStatusBar();
        } finally {
          adjustBoardHeight();
        }
      }

      async function saveBoard() {
        saveBtn.disabled = true;
        setStatus("Savingâ€¦");
        try {
          const resp = await fetch(
            `/api/board/${encodeURIComponent(window.__globals.board.id)}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(board),
            }
          );
          const data = await resp.json();
          board = data;
          boardNameEl.textContent = board.title || "";
          lastSavedJSON = computeSnapshot();
          updateSaveButton();
          setStatus(
            "Saved at " + new Date(board.updatedAt).toLocaleTimeString()
          );
        } catch (e) {
          saveBtn.disabled = false;
          setStatus("Save failed.");
          console.error(e);
        }
      }

      function resetBoard() {
        if (
          !confirm("Clear all nodes/edges? This will NOT save automatically.")
        )
          return;
        const now = new Date().toISOString();
        board = {
          id: board.id || "board-1",
          title: "My Evidence Board",
          nodes: [],
          edges: [],
          createdAt: board.createdAt || now,
          updatedAt: now,
        };
        boardNameEl.textContent = board.title || "";
        render();
        // Mark as dirty so user can decide to Save manually
        markDirty();
        setStatus("Board reset. Click Save to persist.");
      }

      // Image upload handling
      const fileInputEl = document.getElementById("fileInput");
      const uploadBtnEl = document.getElementById("uploadImage");

      uploadBtnEl.onclick = () => fileInputEl.click();

      fileInputEl.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          setStatus("Uploadingâ€¦");
          const fd = new FormData();
          fd.append("image", file);
          const res = await fetch(
            `/api/board/${encodeURIComponent(
              window.__globals.board.id
            )}/upload-image`,
            {
              method: "POST",
              body: fd,
            }
          );
          if (!res.ok) throw new Error("Upload failed");
          const data = await res.json();
          addNode("image", viewCenter(), {
            imageUrl: data.url,
            title: file.name,
          });
          markDirty();
          setStatus("Uploaded.");
        } catch (err) {
          console.error(err);
          alert(err.message || "Upload failed");
          setStatus("Upload failed.");
        } finally {
          fileInputEl.value = "";
        }
      });
      // End of image upload handling

      loadBoard();
    </script>
  </body>
</html>

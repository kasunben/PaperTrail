<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PaperTrail — map your evidence, follow the story.</title>
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.svg" />

    <!-- Primary SEO -->
    <meta name="application-name" content="PaperTrail" />
    <meta
      name="description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta
      name="keywords"
      content="evidence board, investigation, graph, nodes, links, mind map, research, PaperTrail"
    />
    <meta name="robots" content="index,follow" />
    <link rel="canonical" href="/" />
    <meta name="theme-color" content="#ffffff" />

    <!-- Open Graph / Facebook -->
    <meta property="og:site_name" content="PaperTrail" />
    <meta property="og:type" content="website" />
    <meta
      property="og:title"
      content="PaperTrail — map your evidence, follow the story."
    />
    <meta
      property="og:description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta property="og:url" content="/" />
    <meta property="og:image" content="/assets/og-image.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="PaperTrail — map your evidence, follow the story."
    />
    <meta
      name="twitter:description"
      content="PaperTrail is a lightweight evidence-mapping app. Create text, image, and link nodes, connect them, auto-layout, and import/export boards."
    />
    <meta name="twitter:image" content="/assets/og-image.png" />

    <style>
      :root {
        --bg: #ffffff;
        --panel: #111827;
        --muted: #9ca3af;
        --ink: #e5e7eb;
        --accent: #60a5fa;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: var(--ink);
        font: 14px/1.4 ui-sans-serif, system-ui;
      }
      .app-title {
        display: flex;
        flex-direction: column;
        margin-right: 1rem;
      }
      .app-title .brand {
        font-weight: 700;
        font-size: 16px;
        color: #111827;
      }
      .app-title .tagline {
        font-size: 11px;
        color: #6b7280;
      }
      .app-title .board-name {
        font-size: 12px;
        color: #374151;
        margin-top: 2px;
        font-style: italic;
      }
      .board-name[contenteditable="true"] {
        cursor: text;
        border-bottom: 1px dashed #e5e7eb;
        padding-bottom: 1px;
        line-height: 1.2;
        max-width: 280px;
        white-space: normal;
        overflow-wrap: anywhere;
      }
      .board-name[contenteditable="true"]:focus {
        outline: none;
        border-bottom: 1px dashed #60a5fa;
      }
      .board-name[contenteditable="true"]:empty:before {
        content: attr(data-placeholder);
        color: #9ca3af;
      }
      .toolbar {
        display: flex;
        gap: 0.5rem;
        padding: 0.5rem;
        background: #f9fafb;
        color: #111;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        align-items: flex-end;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .toolbar input,
      .toolbar button,
      .toolbar select {
        border: 1px solid #d1d5db;
        background: #ffffff;
        color: #111;
        padding: 0.45rem 0.8rem;
        border-radius: 0.4rem;
        cursor: pointer;
        font-weight: 500;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        transition: background 0.2s, box-shadow 0.2s;
        outline: none;
      }
      .btn-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.45rem;
      }
      .btn-icon svg {
        width: 18px;
        height: 18px;
        stroke: currentColor;
        fill: none;
        stroke-width: 2;
      }
      .btn-icon svg.filled {
        fill: currentColor;
        stroke: none;
      }
      .toolbar button:hover,
      .toolbar select:hover {
        background: #f3f4f6;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .toolbar button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .toolbar .spacer {
        flex: 1;
      }
      .toolbar .search {
        min-width: 250px;
        cursor: text;
      }
      .search-wrap {
        position: relative;
        display: inline-flex;
        align-items: center;
        max-width: 100%;
      }
      .search-wrap input.search {
        flex: 1 1 auto;
        width: 100%;
        padding-right: 1.8em; /* reserve space */
        box-sizing: border-box;
      }
      #clearSearch {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        right: 6px;
        background: transparent;
        border: none;
        font-size: 12px;
        line-height: 1;
        padding: 0 2px 0 0;
        cursor: pointer;
        color: #6b7280;
      }
      #clearSearch:hover {
        color: #111;
      }
      #clearSearch:disabled {
        display: none;
      }
      /* Responsive toolbar */
      @media (max-width: 640px) {
        .toolbar {
          flex-wrap: wrap;
          gap: 6px;
          padding: 0.5rem 0.5rem 0.35rem;
        }
        .app-title {
          flex: 1 1 100%;
          margin-right: 0;
        }
        .app-title .brand {
          font-size: 15px;
        }
        .app-title .tagline {
          font-size: 10px;
        }
        .app-title .board-name {
          max-width: 100%;
          font-size: 12px;
        }

        .toolbar .spacer {
          display: none;
        }

        .btn-icon {
          padding: 0.35rem;
        }
        .btn-icon svg {
          width: 16px;
          height: 16px;
        }
        /* Search gets its own row when wrapping */
        .search-wrap {
          flex: 1 1 100%;
          min-width: 0;
          order: 10;
          position: relative;
          display: flex;
          align-items: center;
        }
        .search-wrap input.search {
          width: 100%;
        }
        /* Right-side controls come after search */
        #autoLayout,
        #export,
        #importBtn,
        #save,
        #reset,
        #infoBtn {
          order: 12;
        }
      }
      /* Board Styles */
      .board {
        position: relative;
        height: calc(
          100% - 24px
        ); /* refined by JS to subtract toolbar height */
        overflow: auto;
        background-image: radial-gradient(var(--muted) 1px, transparent 1px);
        background-size: 16px 16px;
        background-position: -1px -1px;
      }
      #boardSizer {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%; /* will be expanded via JS */
        height: 100%; /* will be expanded via JS */
        pointer-events: none;
        visibility: hidden;
      }
      /* SVG underlay for edges */
      svg#edges {
        position: absolute;
        left: 0;
        top: 0;
        /* no fixed CSS width/height; we size via JS to content extent */
        pointer-events: auto;
        overflow: visible;
      }
      .node {
        position: absolute;
        min-width: 120px;
        max-width: none;
        padding: 0.5rem;
        border-radius: 0.5rem;
        background: #f9fafb;
        border: 1px solid #d1d5db;
        color: #111;
        cursor: grab;
        user-select: none;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        box-sizing: border-box;
      }
      .node:active {
        cursor: grabbing;
      }
      .node .title {
        font-weight: 600;
        margin-bottom: 0.25rem;
        font-size: 13px;
        color: #111827;
        white-space: normal;
        overflow-wrap: anywhere;
        word-break: break-word;
      }
      .node .content {
        font-size: 13px;
        color: #1f2937;
        word-wrap: break-word;
      }
      .node img {
        display: block;
        width: 100%;
        height: auto;
        max-width: 100%;
        border-radius: 0.3rem;
        margin-bottom: 0.35rem;
      }
      .node .ports {
        position: absolute;
        top: 12px; /* better vertical centering with 13px title */
        left: 10px; /* balances with 20px title padding */
        display: flex;
        gap: 4px;
        margin-top: 0;
        align-items: center;
      }
      .node .port {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #94a3b8;
        transition: background 0.2s, border-color 0.2s;
        flex-shrink: 0;
      }
      .node .title {
        padding-left: 18px;
      }
      .node-link .content .rich {
        margin-top: 5px;
      }
      body.connect-mode .node .port {
        background: #ef4444; /* red */
        border-color: #b91c1c;
      }
      #connect.active {
        background: #ef4444;
        color: #fff;
        border-color: #b91c1c;
        box-shadow: 0 2px 6px rgba(239, 68, 68, 0.3);
      }
      #connect.active:hover {
        background: #dc2626;
        box-shadow: 0 3px 8px rgba(220, 38, 38, 0.35);
      }
      .node.selected {
        outline: 2px solid var(--accent);
      }
      /* Resize handle */
      .resizer {
        position: absolute;
        right: 2px;
        bottom: 2px;
        width: 14px;
        height: 14px;
        background: transparent;
        cursor: se-resize;
        display: none;
      }
      .resizer::after {
        content: "";
        position: absolute;
        right: 2px;
        bottom: 2px;
        width: 8px;
        height: 8px;
        border-right: 2px solid #9ca3af;
        border-bottom: 2px solid #9ca3af;
        box-sizing: border-box;
      }
      .node:hover .resizer,
      .node:focus-within .resizer {
        display: block;
      }
      .edge {
        stroke: red;
        stroke-width: 2;
        fill: none;
        stroke-linecap: round;
        stroke-linejoin: round;
        pointer-events: stroke; /* enable clicks on the line only */
        cursor: pointer;
      }
      .edge-endpoint {
        fill: red;
        stroke: #b91c1c;
        stroke-width: 1.2;
        pointer-events: none;
      }
      .edge.selected {
        stroke: var(--accent);
        stroke-width: 3;
      }
      .edge:hover {
        stroke-width: 3;
      }
      .edge.dashed {
        stroke-dasharray: 6 6;
      }
      .edge.ghost {
        stroke: #9ca3af; /* muted */
        stroke-width: 2;
        fill: none;
        stroke-dasharray: 6 6;
        pointer-events: none; /* don't block clicks */
      }
      .edge-label {
        fill: #374151;
        font-size: 11px;
        font-weight: 500;
        user-select: none;
        paint-order: stroke;
        stroke: #f9fafb;
        stroke-width: 2px;
      }
      .hint {
        color: #000000;
        margin-left: 0.5rem;
      }
      .context-menu {
        position: absolute;
        min-width: 180px;
        background: #ffffff;
        border: 1px solid #d1d5db;
        border-radius: 0.5rem;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
        padding: 0.25rem;
        z-index: 1000;
        display: none;
        color: #111;
      }
      .context-menu button {
        width: 100%;
        display: block;
        text-align: left;
        background: transparent;
        border: 0;
        color: #111;
        padding: 0.5rem 0.6rem;
        border-radius: 0.4rem;
        cursor: pointer;
        transition: background 0.15s ease-in-out;
      }
      .context-menu button:hover {
        background: #f3f4f6;
      }
      /* Inline rich text toolbar */
      .rtb {
        position: absolute;
        top: 6px;
        right: 6px;
        display: none;
        background: rgba(255, 255, 255, 0.98);
        border: 1px solid #d1d5db;
        border-radius: 0.4rem;
        padding: 2px;
        gap: 2px;
        z-index: 5;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
      }
      .node:hover .rtb,
      .node:focus-within .rtb {
        display: flex;
      }
      .rtb button {
        border: 0;
        background: transparent;
        color: #111;
        padding: 4px 6px;
        font-size: 12px;
        border-radius: 0.3rem;
        cursor: pointer;
        transition: background 0.15s ease-in-out;
      }
      .rtb button:hover {
        background: #f3f4f6;
      }
      .rich {
        outline: none;
        white-space: pre-wrap;
      }
      .rich a {
        color: #93c5fd;
        text-decoration: underline;
      }
      /* Discoverable editable areas */
      .title[contenteditable="false"] {
        cursor: pointer; /* single-click selects; dblclick enables editing */
      }
      .title[contenteditable="true"] {
        cursor: text;
        border-bottom: 1px dashed #e5e7eb;
        padding-bottom: 2px;
      }
      .node:hover .title[contenteditable="true"] {
        border-bottom-color: #d1d5db;
      }
      .title[contenteditable="true"]:focus {
        outline: none;
        border-bottom-color: #60a5fa;
        box-shadow: inset 0 -1px 0 #60a5fa;
      }
      .title[contenteditable="true"]:empty:before {
        content: attr(data-placeholder);
        color: #9ca3af;
      }
      .rich[contenteditable="true"] {
        cursor: text;
        min-height: 56px;
        padding: 6px 8px;
        background: #ffffff;
        border: 1px dashed #d1d5db;
        border-radius: 6px;
        transition: border-color 0.15s ease, box-shadow 0.15s ease;
      }
      .node:hover .rich[contenteditable="true"] {
        border-color: #cbd5e1;
      }
      .rich[contenteditable="true"]:focus {
        outline: none;
        border-color: #60a5fa;
        box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2);
        background: #fff;
      }
      .rich[contenteditable="true"]:empty:before {
        content: attr(data-placeholder);
        color: #9ca3af;
      }
      /* Small edit affordance on hover */
      .editable-hint::after {
        content: "✎";
        font-size: 11px;
        color: #9ca3af;
        margin-left: 6px;
        opacity: 0;
        transition: opacity 0.15s ease;
      }
      .node:hover .editable-hint::after,
      .editable-hint:focus::after {
        opacity: 1;
      }
      /* Tags */
      .tags {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 2px 8px;
        border-radius: 999px;
        background: #e5e7eb;
        color: #111827;
        font-size: 11px;
        border: 1px solid #d1d5db;
      }
      .chip button {
        border: 0;
        background: transparent;
        color: #9ca3af;
        cursor: pointer;
        font-size: 11px;
        padding: 0;
      }
      .chip button:hover {
        color: #e5e7eb;
      }
      .add-tag {
        margin-top: 6px;
        background: #f3f4f6;
        border: 1px dashed #d1d5db;
        color: #374151;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 11px;
        cursor: pointer;
      }
      .node.dim {
        opacity: 0.35;
        filter: grayscale(0.3);
      }
      .highlight {
        outline: 2px dashed var(--accent);
      }
      .add-desc {
        margin-top: 6px;
        background: #ffffff;
        border: 1px dashed #d1d5db;
        color: #374151;
        border-radius: 12px;
        padding: 2px 8px;
        font-size: 11px;
        cursor: pointer;
      }
      /* Link preview card */
      .link-card {
        display: grid;
        grid-template-columns: 56px 1fr;
        gap: 10px;
        align-items: center;
        padding: 8px;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        background: #ffffff;
        text-decoration: none;
      }
      .link-card .thumb {
        width: 56px;
        height: 56px;
        border-radius: 6px;
        background: #f3f4f6;
        object-fit: cover;
        display: block;
      }
      .link-card .meta {
        min-width: 0;
      }
      .link-card .title {
        font-weight: 600;
        color: #111827;
        font-size: 13px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding: 0;
      }
      .link-card .desc {
        color: #374151;
        font-size: 12px;
        max-height: 2.6em;
        overflow: hidden;
        display: -webkit-box; /* legacy clamp layout */
        line-clamp: 2; /* standard property */
        -webkit-line-clamp: 2; /* vendor fallback */
        -webkit-box-orient: vertical;
      }
      .link-card .site {
        color: #6b7280;
        font-size: 11px;
        margin-top: 2px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .link-card .icon {
        width: 14px;
        height: 14px;
        vertical-align: -2px;
        margin-right: 6px;
        border-radius: 3px;
      }
      .link-card a {
        color: #2563eb;
        text-decoration: none;
      }
      /* Status bar */
      .statusbar {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 2px 12px;
        background: transparent;
        border: none;
        color: #000;
        z-index: 20;
        font-size: smaller;
      }
      .statusbar #status {
        color: #000;
      }
      /* About modal */
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      }
      .modal-backdrop.show {
        display: flex;
      }
      .modal {
        background: #fff;
        color: #111827;
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        width: min(560px, 90vw);
        max-height: 80vh;
        overflow: auto;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
      }
      .modal header {
        padding: 14px 16px;
        border-bottom: 1px solid #f3f4f6;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .modal header h3 {
        margin: 0;
        font-size: 16px;
      }
      .modal header button {
        border: 0;
        background: transparent;
        cursor: pointer;
        font-size: 18px;
        color: #6b7280;
      }
      .modal header button:hover {
        color: #111827;
      }
      .modal .body {
        padding: 0 25px 25px;
        font-size: smaller;
      }
      .kv {
        display: grid;
        grid-template-columns: 140px 1fr;
        gap: 5px;
        margin-top: 8px;
      }
      .kv div {
        padding: 2px 0;
      }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <div class="app-title">
        <div class="brand">PaperTrail</div>
        <div class="tagline">map your evidence, follow the story.</div>
        <div
          class="board-name"
          id="boardName"
          contenteditable="true"
          data-placeholder="Untitled Board"
        ></div>
      </div>
      <button id="addText" class="btn-icon" title="Add text">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="3" width="16" height="18" rx="2" ry="2" />
          <line x1="8" y1="9" x2="16" y2="9" />
          <line x1="8" y1="13" x2="16" y2="13" />
          <line x1="8" y1="17" x2="14" y2="17" />
        </svg>
      </button>
      <button id="addImage" class="btn-icon" title="Add image (URL)">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="3" y="5" width="18" height="14" rx="2" />
          <path d="M7 15l3-3 3 3 4-4 3 3" />
          <circle cx="9" cy="9" r="1.5" />
        </svg>
      </button>
      <button id="uploadImage" class="btn-icon" title="Upload image">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 15V5" />
          <path d="M8 9l4-4 4 4" />
          <path d="M4 19h16" />
        </svg>
      </button>
      <input
        id="fileInput"
        type="file"
        accept="image/*"
        style="display: none"
      />
      <button id="addLink" class="btn-icon" title="Add link">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M10 14l-2 2a4 4 0 0 1-6-6l2-2" />
          <path d="M14 10l2-2a4 4 0 0 1 6 6l-2 2" />
          <path d="M8 12l8-8" opacity="0.0" />
        </svg>
      </button>
      <button id="connect" class="btn-icon" title="Connect nodes (C)">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="6" cy="12" r="2" />
          <circle cx="18" cy="6" r="2" />
          <circle cx="18" cy="18" r="2" />
          <path d="M8 12h6" />
          <path d="M12 12L17 7" />
          <path d="M12 12l5 5" />
        </svg>
      </button>
      <div class="search-wrap">
        <input
          id="search"
          class="search"
          type="search"
          placeholder="Search… (use #tag)"
        />
        <button id="clearSearch" title="Clear search">✕</button>
      </div>
      <div class="spacer"></div>
      <button id="autoLayout" class="btn-icon" title="Auto layout">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="4" width="6" height="6" />
          <rect x="14" y="4" width="6" height="6" />
          <rect x="4" y="14" width="6" height="6" />
          <rect x="14" y="14" width="6" height="6" />
        </svg>
      </button>
      <button id="export" class="btn-icon" title="Export board">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 5v10" />
          <path d="M8 9l4-4 4 4" />
          <path d="M4 19h16" />
        </svg>
      </button>
      <button id="importBtn" class="btn-icon" title="Import board">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 19V9" />
          <path d="M8 15l4 4 4-4" />
          <path d="M4 5h16" />
        </svg>
      </button>
      <input
        id="importFile"
        type="file"
        accept="application/zip,application/x-zip-compressed,.zip,application/json"
        style="display: none"
      />
      <button id="save" class="btn-icon" disabled title="Save">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <rect x="4" y="4" width="16" height="16" rx="2" />
          <rect x="8" y="4" width="8" height="6" />
          <rect x="9" y="14" width="6" height="6" />
        </svg>
      </button>
      <button id="reset" class="btn-icon" title="Reset board">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M3 12a9 9 0 1 0 3-6" />
          <path d="M3 4v6h6" />
        </svg>
      </button>
      <button id="infoBtn" class="btn-icon" title="About / Info">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="12" r="10" />
          <circle cx="12" cy="8" r="1.4" />
          <path d="M12 11v5" stroke-linecap="round" />
        </svg>
      </button>
    </div>
    <div class="board" id="board">
      <div id="boardSizer"></div>
      <svg id="edges"></svg>
    </div>
    <div id="ctxMenu" class="context-menu"></div>
    <div class="statusbar">
      <span id="status"></span>
      <span class="hint" id="modeHint"
        >💡 Mode: Select/Move. Press C to toggle connect mode.</span
      >
    </div>
    <div
      id="aboutModal"
      class="modal-backdrop"
      role="dialog"
      aria-modal="true"
      aria-labelledby="aboutTitle"
    >
      <div class="modal">
        <header>
          <h3 id="aboutTitle">
            PaperTrail — map your evidence, follow the story
          </h3>
          <button type="button" id="aboutClose" aria-label="Close">✕</button>
        </header>
        <div class="body">
          <p>
            <em>PaperTrail</em> is a lightweight visual evidence board for
            organizing ideas, documents, images, and links. It lets you pin down
            pieces of information, connect them freely, and uncover patterns.
            Whether you’re researching, investigating, or just making sense of
            complex projects, PaperTrail helps you create a clear trail of
            evidence you can return to and share.
          </p>
          <p>
            At this stage, PaperTrail is designed as a single-user,
            single-workspace app. That means there is only one active board
            available at a time. Features such as real-time collaboration,
            multi-user access, or simultaneous editing are not yet supported.
          </p>
          <p>
            If you want to manage multiple boards or workspaces, you can still
            do so manually using the Import/Export features:
          </p>
          <ul>
            <li>Export your current board as a .zip file to save it.</li>
            <li>
              Import a previously exported board to continue working on it.
            </li>
            <li>
              You are responsible for organizing these exported files if you
              wish to maintain multiple workspaces.
            </li>
          </ul>
          <p>
            This setup is lightweight and simple, making it ideal for solo use,
            prototyping, or testing out ideas. Future versions of PaperTrail may
            add multi-board support and collaboration features.
          </p>
          <div class="kv">
            <div>App version</div>
            <div id="aboutAppVersion">—</div>
            <div>Schema version</div>
            <div id="aboutSchemaVersion">—</div>
            <div>Current board</div>
            <div id="aboutBoardName">—</div>
          </div>
        </div>
      </div>
    </div>
    <script>
      /** Types (informal)
       * Node = { id, type: 'text'|'image'|'imageText'|'link', x, y, w?, h?, data: { text?, imageUrl?, linkUrl?, title? } }
       * Edge = { id, sourceId, targetId }
       * Board = { id, title, nodes: Node[], edges: Edge[], createdAt, updatedAt }
       */
      const $ = (sel) => document.querySelector(sel);
      const toolbarEl = $(".toolbar");
      const boardEl = $("#board");
      const edgesSvg = $("#edges");
      const statusEl = $("#status");
      const saveBtn = document.getElementById("save");
      const exportBtn = document.getElementById("export");
      const importBtn = document.getElementById("importBtn");
      const importFile = document.getElementById("importFile");
      const searchInput = document.getElementById("search");
      const infoBtn = document.getElementById("infoBtn");
      const aboutModal = document.getElementById("aboutModal");
      const aboutClose = document.getElementById("aboutClose");
      let lastSavedJSON = null;
      let APP_VERSION = "—"; // populated from /api/version

      // Ghost edge state
      let ghostPath = null; // SVGPathElement
      let lastMouse = { x: 0, y: 0 };

      function ensureGhostPath() {
        if (!ghostPath) {
          ghostPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          ghostPath.setAttribute("class", "edge ghost");
          edgesSvg.appendChild(ghostPath);
        } else if (!edgesSvg.contains(ghostPath)) {
          edgesSvg.appendChild(ghostPath);
        }
      }
      function hideGhost() {
        if (ghostPath) ghostPath.setAttribute("d", "");
      }
      function boardPointFromClient(ev) {
        const rect = boardEl.getBoundingClientRect();
        return {
          x: boardEl.scrollLeft + (ev.clientX - rect.left),
          y: boardEl.scrollTop + (ev.clientY - rect.top),
        };
      }
      function renderGhostEdge() {
        if (!connectMode || !connectFromId) {
          hideGhost();
          return;
        }
        const src = board.nodes.find((n) => n.id === connectFromId);
        if (!src) {
          hideGhost();
          return;
        }
        // Use the same smooth cubic logic as permanent edges
        const mx = lastMouse.x,
          my = lastMouse.y;
        const a1 = anchorPoint(src, mx, my);
        const a2 = mouseAnchor(src, mx, my);
        ensureGhostPath();
        ghostPath.setAttribute("d", smoothCubic(a1, a2));
      }

      function adjustBoardHeight() {
        const tb = toolbarEl ? toolbarEl.offsetHeight : 0;
        // 24px = status bar height
        boardEl.style.height = `calc(100% - ${tb}px - 24px)`;
        updateBoardExtent();
      }
      window.addEventListener("resize", adjustBoardHeight);

      boardEl.addEventListener("mousemove", (ev) => {
        lastMouse = boardPointFromClient(ev);
        if (connectMode && connectFromId) renderGhostEdge();
      });
      // Also update when moving over the SVG layer (useful when pointer leaves node area)
      edgesSvg.addEventListener("mousemove", (ev) => {
        lastMouse = boardPointFromClient(ev);
        if (connectMode && connectFromId) renderGhostEdge();
      });

      // Unified status & mode controller
      const ui = {
        connectMode: false,
        status: { text: "", timer: null, sticky: false },
      };
      function renderStatusBar() {
        const modeText = ui.connectMode
          ? "💡 Mode: Connect"
          : "💡 Mode: Select/Move (press C to connect)";
        document.getElementById("modeHint").textContent = modeText;
        statusEl.textContent = ui.status.text || "";
      }
      function setConnectMode(on) {
        ui.connectMode = !!on;
        document.body.classList.toggle("connect-mode", ui.connectMode);
        const connectBtn = document.getElementById("connect");
        connectBtn.classList.toggle("active", ui.connectMode);

        // Disable/enable other toolbar controls
        document.querySelectorAll(".toolbar button").forEach((btn) => {
          if (btn.id === "connect") return;
          btn.disabled = ui.connectMode;
        });

        renderStatusBar();
      }

      // Show a transient status message; use {sticky:true} to persist until changed
      function showStatus(msg, opts = {}) {
        const { sticky = false, ttl = 2200 } = opts;
        // Avoid flicker: ignore if message unchanged
        if (ui.status.text === msg && ui.status.sticky === sticky) return;
        ui.status.text = msg;
        ui.status.sticky = sticky;
        statusEl.textContent = ui.status.text;
        if (ui.status.timer) {
          clearTimeout(ui.status.timer);
          ui.status.timer = null;
        }
        if (!sticky) {
          ui.status.timer = setTimeout(() => {
            ui.status.text = "";
            ui.status.sticky = false;
            renderStatusBar();
          }, ttl);
        }
      }

      // Back-compat wrappers so existing calls keep working
      function setStatus(msg) {
        showStatus(msg);
      }

      const boardNameEl = document.getElementById("boardName");

      // Keep single-line feel: prevent Enter/Return from inserting new lines
      boardNameEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          boardNameEl.blur();
        }
      });

      // Update model on input and enable Save
      boardNameEl.addEventListener("input", () => {
        board.title = (boardNameEl.textContent || "").trim();
        markDirty();
      });

      // On blur, ensure a non-empty title for display (model can be empty if desired)
      boardNameEl.addEventListener("blur", () => {
        if (!boardNameEl.textContent || !boardNameEl.textContent.trim()) {
          boardNameEl.textContent = "Untitled Board";
        }
      });

      function isTypingTarget(el) {
        if (!el) return false;
        if (el.isContentEditable) return true;
        const tag = (el.tagName || "").toUpperCase();
        return tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
      }

      function computeSnapshot() {
        // Exclude volatile fields if needed; for now we snapshot the whole board
        return JSON.stringify(board);
      }
      function updateSaveButton() {
        const snap = computeSnapshot();
        const dirty = lastSavedJSON !== null && snap !== lastSavedJSON;
        saveBtn.disabled = !dirty;
      }
      function markDirty() {
        // Enable save when something changed
        updateSaveButton();
      }
      const ctxMenu = document.getElementById("ctxMenu");
      let ctxTarget = null; // { type: 'node'|'edge', id: string }

      function showContextMenu(x, y, target) {
        ctxTarget = target; // { type, id }
        const menu = ctxMenu;

        // Build menu dynamically based on target type
        if (ctxTarget && ctxTarget.type === "edge") {
          menu.innerHTML = `
            <button data-action="label">Edit label</button>
            <button data-action="dashed">Toggle dashed</button>
            <button data-action="color">Set color…</button>
            <button data-action="delete">Delete</button>
          `;
        } else {
          const node = board.nodes.find((n) => n.id === target.id);
          if (node && node.type === "link") {
            menu.innerHTML = `
              <button data-action="edit-link-url">Edit link URL…</button>
              <button data-action="delete">Delete</button>
            `;
          } else {
            menu.innerHTML = `
              <button data-action="delete">Delete</button>
            `;
          }
        }

        menu.style.display = "block";
        // constrain within window
        const mw = menu.offsetWidth || 160;
        const mh = menu.offsetHeight || 44;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        let px = x,
          py = y;
        if (px + mw > vw) px = vw - mw - 8;
        if (py + mh > vh) py = vh - mh - 8;
        menu.style.left = px + "px";
        menu.style.top = py + "px";
      }
      function hideContextMenu() {
        ctxMenu.style.display = "none";
        ctxTarget = null;
      }

      // clicking elsewhere hides menu
      document.addEventListener("mousedown", (ev) => {
        if (ctxMenu.style.display === "block") {
          const within = ctxMenu.contains(ev.target);
          if (!within) hideContextMenu();
        }
      });

      // Esc hides menu
      document.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape") hideContextMenu();
      });

      // Context menu actions (delegated)
      ctxMenu.addEventListener("click", (ev) => {
        const btn = ev.target.closest("button");
        if (!btn) return;
        const action = btn.getAttribute("data-action");
        if (!ctxTarget) {
          hideContextMenu();
          return;
        }

        if (ctxTarget.type === "node") {
          const node = board.nodes.find((n) => n.id === ctxTarget.id);
          if (!node) {
            hideContextMenu();
            return;
          }

          if (action === "delete") {
            selectedNodeId = ctxTarget.id;
            selectedEdgeId = null;
            hideContextMenu();
            removeSelection();
            return;
          }

          if (action === "edit-link-url" && node.type === "link") {
            const val = prompt("Link URL:", node.data.linkUrl || "https://");
            if (val !== null) {
              const url = (val || "").trim();
              if (url) {
                node.data.linkUrl = url;
                // Invalidate previous preview so it refetches
                delete node.data.preview;
                hideContextMenu();
                markDirty();
                renderNode(node);
                renderEdges();
              }
            }
            return;
          }
          hideContextMenu();
          return;
        }

        // Edge actions
        const edge = board.edges.find((e) => e.id === ctxTarget.id);
        if (!edge) {
          hideContextMenu();
          return;
        }

        if (action === "delete") {
          selectedEdgeId = edge.id;
          selectedNodeId = null;
          hideContextMenu();
          removeSelection();
        } else if (action === "label") {
          const val = prompt("Edge label:", edge.label || "");
          if (val !== null) {
            edge.label = val.trim();
            hideContextMenu();
            markDirty();
            renderEdges();
          }
        } else if (action === "dashed") {
          edge.dashed = !edge.dashed;
          hideContextMenu();
          markDirty();
          renderEdges();
        } else if (action === "color") {
          const val = prompt(
            "Stroke color (e.g. #f87171 or red). Leave blank to reset:",
            edge.color || ""
          );
          if (val === null) return;
          const v = val.trim();
          if (v === "") delete edge.color;
          else edge.color = v;
          hideContextMenu();
          markDirty();
          renderEdges();
        }
      });

      let board = {
        id: "board-1",
        title: "My Evidence Board",
        nodes: [],
        edges: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      // Initialize board name display from default board.title
      boardNameEl.textContent = board.title || "";

      let selectedNodeId = null;
      let selectedEdgeId = null;
      let connectMode = false;
      let connectFromId = null;

      const genId = (p = "id") =>
        p + "-" + Math.random().toString(36).slice(2, 8);

      function addNode(type, at = { x: 100, y: 100 }, payload = {}) {
        const id = genId("n");
        const base = {
          id,
          type,
          x: at.x,
          y: at.y,
          w: 240,
          h: undefined,
          data: {},
        };
        if (type === "text") {
          base.data.text = payload.text ?? "New note...";
          base.data.html = escapeHtml(base.data.text);
          base.data.title = payload.title ?? "Text";
        } else if (type === "image") {
          // Ask for URL if not provided; cancel = no node
          let url = payload.imageUrl;
          if (url === undefined) {
            url = prompt("Image URL?", "");
          }
          if (url === null) return null; // user cancelled
          url = (url || "").trim();
          if (!url) return null; // empty -> abort
          base.data.imageUrl = url;
          base.data.title = payload.title ?? "Image";
          base.data.descHtml = payload.descHtml ?? ""; // optional description (rich)
        } else if (type === "link") {
          // Ask for URL if not provided; cancel = no node
          let url = payload.linkUrl;
          if (url === undefined) {
            url = prompt("Link URL?", "https://");
          }
          if (url === null) return null; // user cancelled
          url = (url || "").trim();
          if (!url) return null; // empty -> abort
          base.data.linkUrl = url;
          base.data.title = payload.title ?? "Link";
          base.data.descHtml = payload.descHtml ?? ""; // optional description (rich)
        }
        board.nodes.push(base);
        markDirty();
        render();
        return base;
      }

      function addEdge(sourceId, targetId) {
        if (!sourceId || !targetId || sourceId === targetId) return;
        const already = board.edges.find(
          (e) => e.sourceId === sourceId && e.targetId === targetId
        );
        if (already) return;
        board.edges.push({ id: genId("e"), sourceId, targetId });
        markDirty();
        renderEdges();
      }

      function removeSelection() {
        if (selectedNodeId) {
          board.edges = board.edges.filter(
            (e) =>
              e.sourceId !== selectedNodeId && e.targetId !== selectedNodeId
          );
          board.nodes = board.nodes.filter((n) => n.id !== selectedNodeId);
          setStatus("Node deleted.");
          selectedNodeId = null;
        } else if (selectedEdgeId) {
          board.edges = board.edges.filter((e) => e.id !== selectedEdgeId);
          setStatus("Edge deleted.");
          selectedEdgeId = null;
        }
        markDirty();
        render();
      }

      function nodeBounds(n) {
        const el = document.getElementById(n.id);
        if (!el)
          return {
            x: n.x,
            y: n.y,
            w: n.w || el?.offsetWidth || 200,
            h: n.h || el?.offsetHeight || 80,
          };
        const w = el.offsetWidth,
          h = el.offsetHeight;
        return { x: n.x, y: n.y, w: n.w || w, h: n.h || h };
      }

      function centerOf(n) {
        const b = nodeBounds(n);
        return { cx: b.x + b.w / 2, cy: b.y + b.h / 2 };
      }

      function renderNode(n) {
        let el = document.getElementById(n.id);
        if (!el) {
          el = document.createElement("div");
          el.className = "node node-" + n.type;
          el.id = n.id;
          el.innerHTML = `
            <div class="title editable-hint" contenteditable="false" data-placeholder="Untitled"></div>
            <div class="content"></div>
            <div class="ports"><div class="port"></div></div>
          `;
          boardEl.appendChild(el);

          // add resize handle
          const resizer = document.createElement("div");
          resizer.className = "resizer";
          el.appendChild(resizer);

          let resizing = false;
          let startW = 0,
            startH = 0,
            startX = 0,
            startY = 0;
          resizer.addEventListener("mousedown", (ev) => {
            ev.stopPropagation();
            resizing = true;
            startX = ev.clientX;
            startY = ev.clientY;
            startW = el.offsetWidth;
            startH = el.offsetHeight;
            document.body.style.userSelect = "none";
          });
          window.addEventListener("mousemove", (ev) => {
            if (!resizing) return;
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;

            const maxW = 640,
              maxH = 600;
            const baseMinW = 160,
              baseMinH = 80;

            // Desired width from drag, clamped to base min/max
            let nextW = Math.max(
              baseMinW,
              Math.min(maxW, Math.round(startW + dx))
            );
            // Apply width first to let text wrap and images scale, then measure content height
            el.style.width = nextW + "px";
            el.style.height = "auto";

            // Content-required height (includes title, content, tags, ports, etc.)
            const contentMinH = Math.ceil(el.scrollHeight);

            // Desired height from drag, but never below content-required height
            let nextH = Math.max(
              baseMinH,
              Math.min(maxH, Math.round(startH + dy))
            );
            nextH = Math.max(nextH, contentMinH);

            // Commit
            n.w = nextW;
            n.h = nextH;
            el.style.height = nextH + "px";

            updateBoardExtent();
            renderEdges();
          });
          window.addEventListener("mouseup", () => {
            if (!resizing) return;
            resizing = false;
            document.body.style.userSelect = "";
            markDirty();
          });

          // select on click
          el.addEventListener("mousedown", (ev) => {
            if (ev.target && ev.target.closest(".resizer")) return;
            // if connect mode, handle port click like connection
            if (connectMode) {
              if (!connectFromId) {
                connectFromId = n.id;
                showStatus("Source selected. Pick a target.", { ttl: 2200 });
                renderGhostEdge();
              } else {
                addEdge(connectFromId, n.id);
                connectFromId = null;
                hideGhost();
                showStatus("Connected.", { ttl: 1800 });
              }
              ev.stopPropagation();
              return;
            }
            selectedEdgeId = null;
            selectedNodeId = n.id;
            updateSelections();
          });
          // right-click to open context menu for this node
          el.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            selectedEdgeId = null;
            selectedNodeId = n.id;
            updateSelections();
            // show menu at mouse position
            showContextMenu(ev.clientX, ev.clientY, { type: "node", id: n.id });
          });
          // drag
          let dragging = false,
            offX = 0,
            offY = 0;
          el.addEventListener("mousedown", (ev) => {
            if (ev.target && ev.target.closest(".resizer")) return;
            dragging = true;
            offX = ev.clientX - n.x;
            offY = ev.clientY - n.y;
          });
          window.addEventListener("mousemove", (ev) => {
            if (!dragging) return;
            n.x = ev.clientX - offX;
            n.y = ev.clientY - offY;
            el.style.left = n.x + "px";
            el.style.top = n.y + "px";
            updateBoardExtent();
            renderEdges(); // update edge positions live
          });
          window.addEventListener("mouseup", () => {
            if (dragging) {
              dragging = false;
              markDirty();
            }
          });

          // inline edits
          const titleEl = el.querySelector(".title");
          titleEl.addEventListener("input", () => {
            n.data.title = titleEl.textContent || "";
            markDirty();
            updateBoardExtent();
            renderEdges(); // keep connections glued to borders as size changes
          });
          // Make title editable only after a double-click
          let _preEditTitle = null;
          function placeCaretAtEnd(node) {
            const r = document.createRange();
            r.selectNodeContents(node);
            r.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(r);
          }
          titleEl.addEventListener("dblclick", (ev) => {
            ev.stopPropagation();
            _preEditTitle = titleEl.textContent;
            titleEl.setAttribute("contenteditable", "true");
            // focus at end
            setTimeout(() => {
              titleEl.focus();
              placeCaretAtEnd(titleEl);
            }, 0);
          });
          // Press Enter to commit, Esc to cancel
          titleEl.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
              ev.preventDefault();
              titleEl.blur();
            } else if (ev.key === "Escape") {
              ev.preventDefault();
              if (_preEditTitle != null) titleEl.textContent = _preEditTitle;
              titleEl.blur();
            }
          });
          titleEl.addEventListener("blur", () => {
            // When leaving edit mode, lock it back
            titleEl.setAttribute("contenteditable", "false");
            _preEditTitle = null;
          });
          el.addEventListener("dblclick", (ev) => {
            if (n.type === "text") {
              // Focus the rich editor instead of opening a prompt
              const rich = el.querySelector(".rich");
              if (rich) {
                rich.focus();
              }
              return; // no prompt
            }

            if (n.type === "image") {
              // Only trigger URL edit when the actual image is double-clicked
              const imgEl = ev.target && ev.target.closest("img");
              if (!imgEl || !el.contains(imgEl)) return; // ignore dblclicks elsewhere in the node
              const url = prompt("Edit image URL:", n.data.imageUrl ?? "");
              if (url !== null) n.data.imageUrl = url;
              renderNode(n);
              renderEdges();
              markDirty();
              return;
            }
          });
        }

        el.style.left = n.x + "px";
        el.style.top = n.y + "px";
        if (n.w) el.style.width = n.w + "px";
        else el.style.removeProperty("width");
        if (n.h) el.style.height = n.h + "px";
        else el.style.removeProperty("height");
        el.classList.toggle("selected", selectedNodeId === n.id);
        // Ensure node type class is correct (in case type changed)
        el.classList.forEach((c) => {
          if (c.startsWith("node-") && c !== "node") el.classList.remove(c);
        });
        el.classList.add("node-" + n.type);

        const titleEl = el.querySelector(".title");
        titleEl.setAttribute(
          "data-placeholder",
          n.type === "text"
            ? "Text title"
            : n.type === "image"
            ? "Image title"
            : "Link title"
        );
        // Preserve existing title; allow empty to show placeholder
        titleEl.textContent =
          typeof n.data.title === "string"
            ? n.data.title
            : n.type === "text"
            ? "Text"
            : n.type === "image"
            ? "Image"
            : "Link";

        const contentEl = el.querySelector(".content");
        if (n.type === "text") {
          const html =
            n.data.html ?? (n.data.text ? escapeHtml(n.data.text) : "");
          contentEl.innerHTML = `
            <div class="rtb" role="toolbar" aria-label="Text formatting">
              <button data-cmd="bold" title="Bold">B</button>
              <button data-cmd="italic" title="Italic"><i>I</i></button>
              <button data-cmd="underline" title="Underline"><u>U</u></button>
              <button data-cmd="insertUnorderedList" title="Bullet list">••</button>
              <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
              <button data-action="link" title="Insert link">🔗</button>
              <button data-action="clear" title="Clear formatting">⨯</button>
            </div>
            <div class="rich" contenteditable="true" data-placeholder="Type text…">${html}</div>`;
        } else if (n.type === "image") {
          const desc = n.data.descHtml ?? "";
          contentEl.innerHTML = n.data.imageUrl
            ? `<img src="${escapeAttr(n.data.imageUrl)}" alt="">` +
              (() => {
                const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
                const wrapDisplay = hasDesc ? "" : 'style="display:none"';
                const addBtn = hasDesc
                  ? ""
                  : `<button class="add-desc" type="button">+ Add description</button>`;
                return `
                  ${addBtn}
                  <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                    <button data-cmd="bold" title="Bold">B</button>
                    <button data-cmd="italic" title="Italic"><i>I</i></button>
                    <button data-cmd="underline" title="Underline"><u>U</u></button>
                    <button data-cmd="insertUnorderedList" title="Bullet list">••</button>
                    <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                    <button data-action="link" title="Insert link">🔗</button>
                    <button data-action="clear" title="Clear formatting">⨯</button>
                  </div>
                  <div class="rich" contenteditable="true" data-field="descHtml" data-placeholder="Add a description…" ${wrapDisplay}>${
                  n.data.descHtml ?? ""
                }</div>
                `;
              })()
            : `<em>No image</em>`;
          // Wire up Add description toggler
          const addDescBtn = el.querySelector(".add-desc");
          if (addDescBtn) {
            addDescBtn.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const rtb = el.querySelector(".rtb");
              const rich = el.querySelector('.rich[data-field="descHtml"]');
              if (rtb) rtb.style.display = "";
              if (rich) rich.style.display = "";
              addDescBtn.remove();
            });
          }
        } else if (n.type === "link") {
          const u = n.data.linkUrl ?? "";
          const desc = n.data.descHtml ?? "";
          if (!u) {
            contentEl.innerHTML = `<em>No link</em>`;
          } else if (n.data.preview) {
            const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
            const wrapDisplay = hasDesc ? "" : 'style="display:none"';
            const addBtn = hasDesc
              ? ""
              : `<button class="add-desc" type="button">+ Add description</button>`;
            contentEl.innerHTML =
              renderLinkCard(n.data.preview, u) +
              `${addBtn}
               <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                 <button data-cmd="bold" title="Bold">B</button>
                 <button data-cmd="italic" title="Italic"><i>I</i></button>
                 <button data-cmd="underline" title="Underline"><u>U</u></button>
                 <button data-cmd="insertUnorderedList" title="Bullet list">••</button>
                 <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                 <button data-action="link" title="Insert link">🔗</button>
                 <button data-action="clear" title="Clear formatting">⨯</button>
               </div>
               <div class="rich" contenteditable="true" data-field="descHtml" data-placeholder="Add a description…" ${wrapDisplay}>${desc}</div>`;
          } else {
            // initial minimal view while loading
            const hasDesc = !!(n.data.descHtml && n.data.descHtml.trim());
            const wrapDisplay = hasDesc ? "" : 'style="display:none"';
            const addBtn = hasDesc
              ? ""
              : `<button class="add-desc" type="button">+ Add description</button>`;
            contentEl.innerHTML =
              `<a href="${escapeAttr(
                u
              )}" target="_blank" rel="noopener">${escapeHtml(u)}</a>` +
              `<div style="margin-top:6px;color:#9ca3af;font-size:12px;">Loading preview…</div>` +
              `${addBtn}
               <div class="rtb" role="toolbar" aria-label="Text formatting" ${wrapDisplay}>
                 <button data-cmd="bold" title="Bold">B</button>
                 <button data-cmd="italic" title="Italic"><i>I</i></button>
                 <button data-cmd="underline" title="Underline"><u>U</u></button>
                 <button data-cmd="insertUnorderedList" title="Bullet list">••</button>
                 <button data-cmd="insertOrderedList" title="Numbered list">1.</button>
                 <button data-action="link" title="Insert link">🔗</button>
                 <button data-action="clear" title="Clear formatting">⨯</button>
               </div>
               <div class="rich" contenteditable="true" data-field="descHtml" data-placeholder="Add a description…" ${wrapDisplay}>${desc}</div>`;
            // kick off preview fetch (once)
            (async () => {
              const p = await fetchLinkPreview(u);
              if (p) {
                n.data.preview = p;
                markDirty();
                renderNode(n);
                renderEdges();
              }
            })();
          }
          // Wire up Add description toggler for Link
          const addDescBtnL = el.querySelector(".add-desc");
          if (addDescBtnL) {
            addDescBtnL.addEventListener("click", (ev) => {
              ev.stopPropagation();
              const rtb = el.querySelector(".rtb");
              const rich = el.querySelector('.rich[data-field="descHtml"]');
              if (rtb) rtb.style.display = "";
              if (rich) rich.style.display = "";
              addDescBtnL.remove();
            });
          }
        }

        // Tags UI (common to all types)
        let tagsWrap = el.querySelector(".tags");
        if (!tagsWrap) {
          tagsWrap = document.createElement("div");
          tagsWrap.className = "tags";
          el.querySelector(".content").appendChild(tagsWrap);
        }
        renderTagChips(n, tagsWrap);

        let addTagBtn = el.querySelector(".add-tag");
        if (!addTagBtn) {
          addTagBtn = document.createElement("button");
          addTagBtn.className = "add-tag";
          addTagBtn.textContent = "+ tag";
          el.querySelector(".content").appendChild(addTagBtn);
          addTagBtn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            const input = prompt("Add tags (comma separated or single #tag):");
            if (!input) return;
            const parts = input
              .split(",")
              .map((s) => normalizeTag(s))
              .filter(Boolean);
            const tags = ensureTags(n);
            for (const t of parts) {
              if (!tags.includes(t)) tags.push(t);
            }
            renderTagChips(n, tagsWrap);
            markDirty();
          });
        }
        // Attach rich text toolbar listeners (Text uses data.html; Image/Link use data.descHtml)
        {
          const rtb = el.querySelector(".rtb");
          const rich = el.querySelector(".rich");
          if (rtb && rich) {
            const field = n.type === "text" ? "html" : "descHtml";
            const isOptionalDesc =
              field === "descHtml" && (n.type === "image" || n.type === "link");

            function ensureAddDescButton() {
              if (!isOptionalDesc) return;
              let addBtn = el.querySelector(".add-desc");
              if (!addBtn) {
                addBtn = document.createElement("button");
                addBtn.className = "add-desc";
                addBtn.type = "button";
                addBtn.textContent = "+ Add description";
                addBtn.addEventListener("click", (ev) => {
                  ev.stopPropagation();
                  if (rtb) rtb.style.display = "";
                  if (rich) rich.style.display = "";
                  addBtn.remove();
                  rich.focus();
                });
                el.querySelector(".content").insertBefore(addBtn, rtb);
              }
            }

            function maybeCollapseIfEmpty() {
              if (!isOptionalDesc) return;
              const plain = (rich.textContent || "").trim();
              const has = plain.length > 0;
              if (!has) {
                // clear stored value and collapse UI
                n.data.descHtml = "";
                if (rtb) rtb.style.display = "none";
                if (rich) {
                  rich.style.display = "none";
                  rich.innerHTML = "";
                }
                ensureAddDescButton();
              }
            }

            // Keep focus inside editor when clicking toolbar
            rtb.addEventListener("mousedown", (ev) => {
              ev.preventDefault();
              rich.focus();
            });
            rtb.addEventListener("click", (ev) => {
              const btn = ev.target.closest("button");
              if (!btn) return;
              const cmd = btn.getAttribute("data-cmd");
              const act = btn.getAttribute("data-action");
              rich.focus();
              if (cmd) {
                document.execCommand(cmd, false, null);
                n.data[field] = rich.innerHTML;
                markDirty();
                renderEdges();
                maybeCollapseIfEmpty();
              } else if (act === "link") {
                const url = prompt("Link URL", "https://");
                if (url) document.execCommand("createLink", false, url);
                n.data[field] = rich.innerHTML;
                markDirty();
                maybeCollapseIfEmpty();
              } else if (act === "clear") {
                document.execCommand("removeFormat");
                const a = rich.querySelector("a");
                if (a) {
                  const t = document.createTextNode(a.textContent || "");
                  a.replaceWith(t);
                }
                rich.innerHTML = "";
                n.data[field] = "";
                markDirty();
                maybeCollapseIfEmpty();
              }
            });

            const syncHtml = () => {
              n.data[field] = rich.innerHTML;
              markDirty();
              maybeCollapseIfEmpty();
            };
            rich.addEventListener("input", syncHtml);
            rich.addEventListener("blur", syncHtml);
          }
        }
        // Toggle resizer visibility based on node type (text, image, link are resizable)
        const resizerEl = el.querySelector(".resizer");
        if (resizerEl) {
          resizerEl.style.display =
            n.type === "text" || n.type === "image" || n.type === "link"
              ? ""
              : "none";
        }
      }

      function renderNodes() {
        // Remove DOM nodes that no longer exist in data
        const ids = new Set(board.nodes.map((n) => n.id));
        document.querySelectorAll(".node").forEach((el) => {
          if (!ids.has(el.id)) el.remove();
        });
        board.nodes.forEach(renderNode);
      }

      // Compute an anchor point on the boundary of node n that faces (ox, oy)
      function anchorPoint(n, ox, oy) {
        const b = nodeBounds(n);
        const cx = b.x + b.w / 2;
        const cy = b.y + b.h / 2;
        const dx = ox - cx;
        const dy = oy - cy;

        // Choose side by dominant axis
        if (Math.abs(dx) > Math.abs(dy)) {
          // left/right
          if (dx >= 0) {
            return { x: b.x + b.w, y: cy, side: "right" };
          } else {
            return { x: b.x, y: cy, side: "left" };
          }
        } else {
          // top/bottom
          if (dy >= 0) {
            return { x: cx, y: b.y + b.h, side: "bottom" };
          } else {
            return { x: cx, y: b.y, side: "top" };
          }
        }
      }

      function oppositeSide(side) {
        switch (side) {
          case "left":
            return "right";
          case "right":
            return "left";
          case "top":
            return "bottom";
          case "bottom":
            return "top";
          default:
            return "right";
        }
      }

      // Build a synthetic “target” anchor at the mouse so the curve bends nicely.
      // We pick the side opposite to where the mouse is relative to the source node,
      // so control points push outward (pleasant S-curve).
      function mouseAnchor(fromNode, mx, my) {
        const b = nodeBounds(fromNode);
        const cx = b.x + (b.w || 0) / 2;
        const cy = b.y + (b.h || 0) / 2;
        const dx = mx - cx;
        const dy = my - cy;
        let side;
        if (Math.abs(dx) > Math.abs(dy)) {
          side = dx >= 0 ? "left" : "right"; // opposite of mouse horizontal side
        } else {
          side = dy >= 0 ? "top" : "bottom"; // opposite of mouse vertical side
        }
        return { x: mx, y: my, side };
      }

      // Smooth cubic path between two anchors, with curvature adaptive to distance
      function smoothCubic(a, b) {
        const x1 = a.x,
          y1 = a.y,
          x2 = b.x,
          y2 = b.y;
        const dx = Math.abs(x2 - x1);
        const dy = Math.abs(y2 - y1);
        const d = Math.max(dx, dy);
        const c = Math.min(160, Math.max(40, d * 0.6)); // curvature

        let c1x = x1,
          c1y = y1,
          c2x = x2,
          c2y = y2;

        // Push control points outward from each side
        switch (a.side) {
          case "right":
            c1x += c;
            break;
          case "left":
            c1x -= c;
            break;
          case "top":
            c1y -= c;
            break;
          case "bottom":
            c1y += c;
            break;
        }
        switch (b.side) {
          case "right":
            c2x -= c;
            break;
          case "left":
            c2x += c;
            break;
          case "top":
            c2y += c;
            break;
          case "bottom":
            c2y -= c;
            break;
        }

        return `M ${x1} ${y1} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x2} ${y2}`;
      }

      function computeContentExtent(pad = 160) {
        let maxX = 0,
          maxY = 0;
        for (const n of board.nodes) {
          const b = nodeBounds(n);
          const w = b.w || 240;
          const h = b.h || 100;
          maxX = Math.max(maxX, b.x + w);
          maxY = Math.max(maxY, b.y + h);
        }
        const rect = boardEl.getBoundingClientRect();
        const w = Math.max(maxX + pad, rect.width);
        const h = Math.max(maxY + pad, rect.height);
        return { w, h };
      }

      function updateBoardExtent() {
        const { w, h } = computeContentExtent(160);
        const sizer = document.getElementById("boardSizer");
        if (sizer) {
          sizer.style.width = w + "px";
          sizer.style.height = h + "px";
        }
        edgesSvg.setAttribute("width", w);
        edgesSvg.setAttribute("height", h);
        edgesSvg.style.width = w + "px";
        edgesSvg.style.height = h + "px";
      }

      function renderEdges() {
        edgesSvg.innerHTML = "";
        updateBoardExtent();
        if (!visibleNodeIds) {
          visibleNodeIds = new Set(board.nodes.map((n) => n.id));
        }

        for (const e of board.edges) {
          const s = board.nodes.find((n) => n.id === e.sourceId);
          const t = board.nodes.find((n) => n.id === e.targetId);
          if (!s || !t) continue;
          if (!visibleNodeIds.has(s.id) || !visibleNodeIds.has(t.id)) continue;
          const sc = centerOf(s);
          const tc = centerOf(t);
          const a1 = anchorPoint(s, tc.cx, tc.cy);
          const a2 = anchorPoint(t, sc.cx, sc.cy);
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.setAttribute("data-id", e.id);

          // Path
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute("d", smoothCubic(a1, a2));
          let cls = "edge" + (selectedEdgeId === e.id ? " selected" : "");
          if (e.dashed) cls += " dashed";
          path.setAttribute("class", cls);
          if (e.color) {
            // Use inline style so it overrides the .edge CSS rule
            path.style.stroke = e.color;
          } else {
            path.style.stroke = null; // fall back to CSS (.edge { stroke: red; })
          }
          path.dataset.id = e.id;

          // Label (optional)
          if (e.label) {
            const tx = (a1.x + a2.x) / 2;
            const ty = (a1.y + a2.y) / 2 - 2; // closer to the curve
            const text = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            text.setAttribute("x", tx);
            text.setAttribute("y", ty);
            text.setAttribute("class", "edge-label");
            text.textContent = e.label;

            // Click/ctx on label behave like the edge
            text.addEventListener("click", (ev) => {
              selectedNodeId = null;
              selectedEdgeId = e.id;
              updateSelections();
              ev.stopPropagation();
              return false;
            });
            text.addEventListener("contextmenu", (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              selectedNodeId = null;
              selectedEdgeId = e.id;
              updateSelections();
              showContextMenu(ev.clientX, ev.clientY, {
                type: "edge",
                id: e.id,
              });
              return false;
            });
            g.appendChild(text);
          }

          // Events on path
          path.addEventListener("click", (ev) => {
            selectedNodeId = null;
            selectedEdgeId = e.id;
            updateSelections();
            ev.stopPropagation();
            return false;
          });
          path.addEventListener("contextmenu", (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            selectedNodeId = null;
            selectedEdgeId = e.id;
            updateSelections();
            showContextMenu(ev.clientX, ev.clientY, { type: "edge", id: e.id });
            return false;
          });

          g.appendChild(path);

          // Add endpoint circles
          const startCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          startCircle.setAttribute("cx", a1.x);
          startCircle.setAttribute("cy", a1.y);
          startCircle.setAttribute("r", "4");
          startCircle.setAttribute("class", "edge-endpoint");

          const endCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          endCircle.setAttribute("cx", a2.x);
          endCircle.setAttribute("cy", a2.y);
          endCircle.setAttribute("r", "4");
          endCircle.setAttribute("class", "edge-endpoint");

          g.appendChild(startCircle);
          g.appendChild(endCircle);

          edgesSvg.appendChild(g);
        }
        // Re-draw ghost on top if we're mid-connection
        if (connectMode && connectFromId) {
          renderGhostEdge();
        } else {
          hideGhost();
        }
      }

      function updateSelections() {
        // nodes
        document.querySelectorAll(".node").forEach((el) => {
          el.classList.toggle("selected", el.id === selectedNodeId);
        });
        // edges
        document.querySelectorAll("path.edge").forEach((p) => {
          p.classList.toggle("selected", p.dataset.id === selectedEdgeId);
        });
      }

      function render() {
        renderNodes();
        renderEdges();
        applySearchFilter();
        adjustBoardHeight();
      }

      function escapeHtml(s) {
        return (s ?? "").toString().replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function escapeAttr(s) {
        return escapeHtml(s);
      }

      function ensureTags(n) {
        if (!n.data) n.data = {};
        if (!Array.isArray(n.data.tags)) n.data.tags = [];
        return n.data.tags;
      }
      function normalizeTag(t) {
        return (t || "").toString().trim().replace(/^#+/, "").toLowerCase();
      }
      function renderTagChips(n, hostEl) {
        const tags = ensureTags(n);
        hostEl.innerHTML = "";
        for (let i = 0; i < tags.length; i++) {
          const tag = tags[i];
          const chip = document.createElement("span");
          chip.className = "chip";
          chip.innerHTML = `<span>#${escapeHtml(
            tag
          )}</span> <button title="Remove tag" data-i="${i}">✕</button>`;
          chip.querySelector("button").addEventListener("click", (ev) => {
            ev.stopPropagation();
            tags.splice(i, 1);
            renderTagChips(n, hostEl);
            markDirty();
          });
          hostEl.appendChild(chip);
        }
      }

      function plainTextFromHtml(html) {
        const tmp = document.createElement("div");
        tmp.innerHTML = html || "";
        return (tmp.textContent || tmp.innerText || "").trim();
      }

      let currentQuery = "";
      let visibleNodeIds = null; // Set<string>

      function parseQuery(q) {
        const parts = (q || "").trim().split(/\\s+/).filter(Boolean);
        const tags = [];
        const terms = [];
        for (const p of parts) {
          if (p.startsWith("#")) tags.push(normalizeTag(p));
          else terms.push(p.toLowerCase());
        }
        return { tags, terms };
      }

      function nodeMatches(n, q) {
        if (!q || (!q.tags.length && !q.terms.length)) return true;
        const tags = ensureTags(n);
        // tag logic: all query tags must be present
        for (const t of q.tags) {
          if (!tags.map(normalizeTag).includes(t)) return false;
        }
        if (!q.terms.length) return true;
        const hay = [
          n.data?.title || "",
          n.data?.text || "",
          plainTextFromHtml(n.data?.html || ""),
          n.data?.linkUrl || "",
          tags.join(" "),
        ]
          .join(" ")
          .toLowerCase();
        return q.terms.every((term) => hay.includes(term));
      }

      function applySearchFilter() {
        const q = parseQuery(currentQuery);
        visibleNodeIds = new Set();
        for (const n of board.nodes) {
          const el = document.getElementById(n.id);
          const match = nodeMatches(n, q);
          if (el) {
            el.style.display = match ? "" : "none";
            el.classList.toggle("dim", !match && currentQuery.length > 0);
          }
          if (match) visibleNodeIds.add(n.id);
        }
        renderEdges();
      }

      function slugify(s) {
        return (s || "board")
          .toString()
          .toLowerCase()
          .replace(/\s+/g, "-")
          .replace(/[^a-z0-9-_]/g, "-")
          .replace(/-+/g, "-")
          .replace(/^-|-$/g, "");
      }

      function exportBoard() {
        // Let the server stream a ZIP (includes board.json and uploads/)
        showStatus("Export in progress…", { sticky: true });
        // Trigger the download
        window.location.href = "/api/board/export";
        // After a short delay, update the message to guide user
        setTimeout(() => {
          showStatus(
            "Export initiated. Please check your downloads folder once it completes.",
            { sticky: true }
          );
        }, 500);
      }

      async function fetchLinkPreview(url) {
        try {
          const res = await fetch("/api/link-preview", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ url }),
          });
          if (!res.ok) throw new Error("Failed");
          return await res.json();
        } catch (e) {
          return null;
        }
      }

      function renderLinkCard(preview, href) {
        const title = escapeHtml(preview?.title || href || "Link");
        const desc = escapeHtml(preview?.description || "");
        const site = escapeHtml(
          preview?.siteName || (href ? new URL(href).hostname : "")
        );
        const icon = preview?.icon
          ? `<img class="icon" src="${escapeAttr(preview.icon)}" alt="">`
          : "";
        const img = preview?.image
          ? `<img class="thumb" src="${escapeAttr(preview.image)}" alt="">`
          : `<div class="thumb"></div>`;
        const safeHref = escapeAttr(href || preview?.url || "#");
        return `
          <a href="${safeHref}" target="_blank" rel="noopener" class="link-card">
            ${img}
            <div class="meta">
              <div class="title">${title}</div>
              ${desc ? `<div class="desc">${desc}</div>` : ""}
              <div class="site">${icon}${site}</div>
            </div>
          </a>
        `;
      }

      function validateImported(json) {
        if (!json || typeof json !== "object")
          throw new Error("File is not a JSON object");
        if (!Array.isArray(json.nodes) || !Array.isArray(json.edges))
          throw new Error("Missing nodes/edges arrays");
        // Minimal normalization: ensure required fields exist
        json.id = json.id || "board-1";
        json.title = json.title || "Imported Board";
        json.createdAt = json.createdAt || new Date().toISOString();
        json.updatedAt = new Date().toISOString();
        json.nodes = json.nodes.map((n, i) => ({
          id: n.id || `n_imp_${i}`,
          type: n.type || "text",
          x: Number.isFinite(n.x) ? n.x : 100 + i * 20,
          y: Number.isFinite(n.y) ? n.y : 100 + i * 20,
          w: n.w,
          h: n.h,
          data: n.data || {},
        }));
        json.edges = json.edges
          .filter((e) => e && e.sourceId && e.targetId)
          .map((e, i) => ({
            id: e.id || `e_imp_${i}`,
            sourceId: e.sourceId,
            targetId: e.targetId,
          }));
        return json;
      }

      // --- Auto-layout (simple layered layout, dagre-like) ---
      function buildGraph() {
        const nodes = board.nodes.map((n) => ({ id: n.id }));
        const edges = board.edges.map((e) => ({
          from: e.sourceId,
          to: e.targetId,
        }));
        const adj = new Map();
        const indeg = new Map();
        for (const n of nodes) {
          adj.set(n.id, []);
          indeg.set(n.id, 0);
        }
        for (const e of edges) {
          if (!adj.has(e.from)) adj.set(e.from, []);
          adj.get(e.from).push(e.to);
          if (indeg.has(e.to)) indeg.set(e.to, indeg.get(e.to) + 1);
          else indeg.set(e.to, 1);
        }
        return { nodes, edges, adj, indeg };
      }

      function topoLayers() {
        const { nodes, adj, indeg } = buildGraph();
        const q = [];
        const indegCopy = new Map(indeg);
        for (const n of nodes)
          if ((indegCopy.get(n.id) || 0) === 0) q.push(n.id);
        const layers = [];
        const placed = new Set();
        // Kahn-like layering: nodes with indegree==0 form layer 0, then peel
        let current = q.slice();
        let visitedCount = 0;
        while (current.length) {
          layers.push(current);
          const next = [];
          for (const id of current) {
            placed.add(id);
            visitedCount++;
            const outs = adj.get(id) || [];
            for (const v of outs) {
              indegCopy.set(v, (indegCopy.get(v) || 0) - 1);
              if (indegCopy.get(v) === 0) next.push(v);
            }
          }
          current = next;
        }
        // Any remaining nodes are in cycles; place them in subsequent layers by a simple BFS from any unplaced
        if (visitedCount < nodes.length) {
          const rest = nodes.map((n) => n.id).filter((id) => !placed.has(id));
          // group into chunks of up to 5 per layer to avoid stacking all in one
          const chunk = 5;
          for (let i = 0; i < rest.length; i += chunk)
            layers.push(rest.slice(i, i + chunk));
        }
        return layers;
      }

      function autoLayout(direction = "LR") {
        if (!board.nodes.length) return;
        // Ensure DOM sizes are measured before layout
        renderNodes();
        // Build layered structure
        const layers = topoLayers();
        const layerGap = 180; // distance between layers
        const nodeGap = 80; // distance between nodes within a layer

        // Precompute sizes
        const size = new Map();
        for (const n of board.nodes) {
          const b = nodeBounds(n);
          size.set(n.id, { w: b.w || 240, h: b.h || 100 });
        }

        if (direction === "LR") {
          // Layers progress left-to-right; within each layer, nodes are stacked vertically
          let x = 80;
          for (const layer of layers) {
            // compute max width in this layer
            let maxW = 0;
            for (const id of layer) {
              maxW = Math.max(maxW, size.get(id)?.w || 240);
            }
            // vertical placement centered around the board's current view
            let y = 80;
            for (const id of layer) {
              const n = board.nodes.find((nn) => nn.id === id);
              if (!n) continue;
              const wh = size.get(id) || { w: 240, h: 100 };
              n.x = x;
              n.y = y;
              y += wh.h + nodeGap;
            }
            x += maxW + layerGap;
          }
        } else {
          // TB top-to-bottom
          let y = 80;
          for (const layer of layers) {
            let maxH = 0;
            for (const id of layer) {
              maxH = Math.max(maxH, size.get(id)?.h || 100);
            }
            let x = 80;
            for (const id of layer) {
              const n = board.nodes.find((nn) => nn.id === id);
              if (!n) continue;
              const wh = size.get(id) || { w: 240, h: 100 };
              n.x = x;
              n.y = y;
              x += wh.w + nodeGap;
            }
            y += maxH + layerGap;
          }
        }
        render();
        markDirty();
        setStatus("Auto-layout applied");
      }

      // Ensure status bar hint is rendered on first load
      renderStatusBar();
      adjustBoardHeight();

      // Load app + schema version from server
      (async () => {
        try {
          const r = await fetch("/api/version");
          if (r.ok) {
            const j = await r.json();
            if (j && typeof j.version === "string") APP_VERSION = j.version;
            if (j && typeof j.schemaVersion !== "undefined") {
              if (!board.schemaVersion) board.schemaVersion = j.schemaVersion;
            }
          }
        } catch {}
      })();
      function openAbout() {
        document.getElementById("aboutAppVersion").textContent = APP_VERSION;
        document.getElementById("aboutSchemaVersion").textContent = String(
          board.schemaVersion || 1
        );
        document.getElementById("aboutBoardName").textContent =
          board.title || "Untitled Board";
        aboutModal.classList.add("show");
      }
      function closeAbout() {
        aboutModal.classList.remove("show");
      }

      // Toolbar wiring
      $("#addText").onclick = () =>
        addNode("text", viewCenter(), { text: "New note..." });
      $("#addImage").onclick = () => addNode("image", viewCenter());
      $("#addLink").onclick = () => addNode("link", viewCenter());
      $("#connect").onclick = toggleConnectMode;
      document.getElementById("autoLayout").onclick = () => autoLayout("LR");
      exportBtn.onclick = exportBoard;
      importBtn.onclick = () => importFile.click();
      infoBtn.addEventListener("click", openAbout);
      aboutClose.addEventListener("click", closeAbout);
      aboutModal.addEventListener("click", (e) => {
        if (e.target === aboutModal) closeAbout();
      });
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (aboutModal.classList.contains("show")) closeAbout();
          if (connectMode && connectFromId) {
            connectFromId = null;
            hideGhost();
            showStatus("Connect cancelled");
          }
        }
      });

      boardEl.addEventListener("mousedown", (ev) => {
        if (!ev.target || ev.target === boardEl) {
          if (connectMode && connectFromId) {
            connectFromId = null;
            hideGhost();
            showStatus("Connect cancelled");
          }
        }
      });
      importFile.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          if (/\.zip$/i.test(file.name)) {
            // Probe first
            const probeFd = new FormData();
            probeFd.append("bundle", file);
            const probeRes = await fetch("/api/board/probeZip", {
              method: "POST",
              body: probeFd,
            });
            if (!probeRes.ok)
              throw new Error(`Probe failed (${probeRes.status})`);
            const meta = await probeRes.json();

            if (meta.boardId === board.id) {
              const ok = confirm(
                `You're importing the SAME board (ID: ${
                  meta.boardId
                }).\nTitle: ${
                  meta.title || "(untitled)"
                }\nReplace the current board with the imported one?`
              );
              if (!ok) {
                setStatus("Import cancelled.");
                importFile.value = "";
                return;
              }
            }

            setStatus("Importing zip…");
            const fd = new FormData();
            fd.append("bundle", file);
            const res = await fetch("/api/board/importZip", {
              method: "POST",
              body: fd,
            });
            if (!res.ok) throw new Error(`Import failed (${res.status})`);
            const json = await res.json();
            board = json;
            render();
            markDirty();
            setStatus(`Imported ${file.name}`);
          } else {
            const text = await file.text();
            const json = JSON.parse(text);
            const validated = validateImported(json);
            if (validated.id === board.id) {
              const ok = confirm(
                `You're importing the SAME board (ID: ${validated.id}). Replace the current board with the imported one?`
              );
              if (!ok) {
                setStatus("Import cancelled.");
                importFile.value = "";
                return;
              }
            }
            board = validated;
            render();
            markDirty();
            setStatus(`Imported ${file.name}`);
          }
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
          setStatus("Import failed.");
        } finally {
          importFile.value = "";
        }
      });
      // Search wiring (debounced + clear)
      let searchTimer = null;
      const clearSearchBtn = document.getElementById("clearSearch");
      const updateClearBtn = () => {
        clearSearchBtn.disabled = !searchInput.value;
      };
      updateClearBtn();

      searchInput.addEventListener("input", (e) => {
        currentQuery = e.target.value || "";
        if (searchTimer) clearTimeout(searchTimer);
        searchTimer = setTimeout(() => applySearchFilter(), 150);
        updateClearBtn();
      });

      // Allow Esc to clear search without triggering global handlers
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          searchInput.value = "";
          currentQuery = "";
          applySearchFilter();
          updateClearBtn();
          e.stopPropagation();
        }
      });

      // Clear button
      clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        currentQuery = "";
        applySearchFilter();
        updateClearBtn();
        searchInput.focus();
      });
      $("#save").onclick = saveBoard;
      $("#reset").onclick = resetBoard;

      function viewCenter() {
        const rect = boardEl.getBoundingClientRect();
        return {
          x: boardEl.scrollLeft + rect.width / 2 - 120,
          y: boardEl.scrollTop + rect.height / 2 - 60,
        };
      }

      /** Info Button */
      function openAbout() {
        document.getElementById("aboutAppVersion").textContent = APP_VERSION;
        document.getElementById("aboutSchemaVersion").textContent = String(
          board.schemaVersion || 1
        );
        document.getElementById("aboutBoardName").textContent =
          board.title || "Untitled Board";
        aboutModal.classList.add("show");
      }

      function closeAbout() {
        aboutModal.classList.remove("show");
      }

      infoBtn.addEventListener("click", openAbout);
      aboutClose.addEventListener("click", closeAbout);
      // Close when clicking the backdrop
      aboutModal.addEventListener("click", (e) => {
        if (e.target === aboutModal) closeAbout();
      });
      // Close on Esc
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && aboutModal.classList.contains("show"))
          closeAbout();
      });
      /** end of Info Button */

      function toggleConnectMode() {
        connectMode = !connectMode;
        connectFromId = null;
        setConnectMode(connectMode);
      }

      document.addEventListener("keydown", (e) => {
        const typing = isTypingTarget(e.target);

        if (!typing && (e.key === "Delete" || e.key === "Backspace")) {
          e.preventDefault(); // avoid browser back
          removeSelection();
          return;
        }
        if (!typing && e.key.toLowerCase() === "c") {
          toggleConnectMode();
          return;
        }
        if (e.key.toLowerCase() === "l" && (e.metaKey || e.ctrlKey)) {
          e.preventDefault();
          autoLayout("LR");
        }
      });

      // click blank space to clear selection
      boardEl.addEventListener("mousedown", (ev) => {
        if (ev.target === boardEl || ev.target === edgesSvg) {
          hideContextMenu();
          selectedNodeId = null;
          selectedEdgeId = null;
          updateSelections();
        }
      });
      // Allow dropping a .json file onto the board to import
      boardEl.addEventListener("dragover", (e) => {
        e.preventDefault();
      });
      boardEl.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer?.files?.[0];
        if (!file || !file.name.toLowerCase().endsWith(".json")) return;
        try {
          const text = await file.text();
          const json = JSON.parse(text);
          const validated = validateImported(json);
          board = validated;
          render();
          markDirty();
          setStatus(`Imported ${file.name}`);
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
          setStatus("Import failed.");
        }
      });

      // Load existing board
      async function loadBoard() {
        try {
          const res = await fetch("/api/board");
          const data = await res.json();
          board = data;
          render();
          boardNameEl.textContent = board.title || "";
          lastSavedJSON = computeSnapshot();
          updateSaveButton();
          currentQuery = searchInput.value || "";
          applySearchFilter();
          setStatus("Loaded.");
          renderStatusBar();
        } catch (e) {
          setStatus("No saved board yet. Start adding nodes.");
          renderStatusBar();
        } finally {
          adjustBoardHeight();
        }
      }

      async function saveBoard() {
        saveBtn.disabled = true;
        setStatus("Saving…");
        try {
          const res = await fetch("/api/board", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(board),
          });
          const data = await res.json();
          board = data;
          boardNameEl.textContent = board.title || "";
          lastSavedJSON = computeSnapshot();
          updateSaveButton();
          setStatus(
            "Saved at " + new Date(board.updatedAt).toLocaleTimeString()
          );
        } catch (e) {
          saveBtn.disabled = false;
          setStatus("Save failed.");
          console.error(e);
        }
      }

      function resetBoard() {
        if (
          !confirm("Clear all nodes/edges? This will NOT save automatically.")
        )
          return;
        const now = new Date().toISOString();
        board = {
          id: board.id || "board-1",
          title: "My Evidence Board",
          nodes: [],
          edges: [],
          createdAt: board.createdAt || now,
          updatedAt: now,
        };
        boardNameEl.textContent = board.title || "";
        render();
        // Mark as dirty so user can decide to Save manually
        markDirty();
        setStatus("Board reset. Click Save to persist.");
      }

      // Image upload handling
      const fileInputEl = document.getElementById("fileInput");
      const uploadBtnEl = document.getElementById("uploadImage");

      uploadBtnEl.onclick = () => fileInputEl.click();

      fileInputEl.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          setStatus("Uploading…");
          const fd = new FormData();
          fd.append("image", file);
          const res = await fetch("/api/upload", { method: "POST", body: fd });
          if (!res.ok) throw new Error("Upload failed");
          const data = await res.json();
          addNode("image", viewCenter(), {
            imageUrl: data.url,
            title: file.name,
          });
          markDirty();
          setStatus("Uploaded.");
        } catch (err) {
          console.error(err);
          alert(err.message || "Upload failed");
          setStatus("Upload failed.");
        } finally {
          fileInputEl.value = "";
        }
      });
      // End of image upload handling

      loadBoard();
    </script>
  </body>
</html>
